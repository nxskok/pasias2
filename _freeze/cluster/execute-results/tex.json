{
  "hash": "9e295aecb60c352026e25da162061531",
  "result": {
    "markdown": "# Hierarchical cluster analysis\n\nPackages for this chapter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nlibrary(ggbiplot)\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n##  Sites on the sea bed\n\n\n Biologists investigate the prevalence of\nspecies of organism by sampling sites where the organisms might be,\ntaking a \"grab\" from the site, and sending the grabs to a laboratory\nfor analysis. The data in this question come from the sea bed. There\nwere 30 sites, labelled `s1` through `s30`. At each\nsite, five species of organism, labelled `a` through\n`e`, were of interest; the data shown in those columns of the\ndata set were the number of organisms of that species identified in\nthe grab from that site. There are some other columns in the\n(original) data set that will not concern us. Our interest is in\nseeing which sites are similar to which other sites, so that a cluster\nanalysis will be suitable.\n\nWhen the data are counts of different species, as they are here,\nbiologists often measure the dissimilarity in species prevalence\nprofiles between two sites using something called the Bray-Curtis\ndissimilarity. It is not important to understand this for this\nquestion (though I explain it in my solutions). I calculated the\nBray-Curtis dissimilarity between each pair of sites and stored the\nresults in [link](http://ritsokiguess.site/datafiles/seabed1.csv). \n\n\n\n(a) Read in the dissimilarity data and check that you have 30\nrows and 30 columns of dissimilarities.\n\n\n\n(b) Create a distance object out of your dissimilarities,\nbearing in mind that the values are distances (well,\ndissimilarities) already.\n\n\n\n(c) Fit a cluster analysis using single-linkage, and display a\ndendrogram of the results.\n\n\n\n(d) Now fit a cluster analysis using Ward's method, and display\na dendrogram of the results.\n\n\n\n(e) <a name=\"part:prefclust\">*</a> On the Ward's method clustering, how many clusters would you\nchoose to divide the sites into? Draw rectangles around those clusters.\n\n\n\n\n(f) <a name=\"part:original\">*</a> The original data is in\n[link](http://ritsokiguess.site/datafiles/seabed.csv). Read in the\noriginal data and verify that you again have 30 sites, variables\ncalled `a` through `e` and some others.\n\n\n\n\n(g) Go back to your Ward method dendrogram with the red\nrectangles and find two sites in the same cluster. Display the\noriginal data for your two sites and see if you can explain why they\nare in the same cluster. It doesn't matter which two sites you choose;\nthe grader will merely check that your results look reasonable.\n\n\n\n\n(h) Obtain the cluster memberships for each site, for your\npreferred number of clusters from part (<a href=\"#part:prefclust\">here</a>). Add a\ncolumn to the original data that you read in, in part\n(<a href=\"#part:original\">here</a>), containing those cluster memberships, *as a\nfactor*.  Obtain a plot that will enable you to assess the\nrelationship between those clusters and `pollution`. (Once you\nhave the cluster memberships, you can add them to the data frame and\nmake the graph using a pipe.)  What do you see?\n\n\n\n\n\n\n\n\n\n\n##  Dissimilarities between fruits\n\n\n Consider the fruits apple, orange, banana, pear,\nstrawberry, blueberry. We are going to work with these four\nproperties of fruits:\n\n\n* has a round shape\n\n* Is sweet\n\n* Is crunchy\n\n* Is a berry\n\n\n\n(a)  Make a table with fruits as columns, and with\nrows \"round shape\", \"sweet\", \"crunchy\", \"berry\". In each cell\nof the table, put a 1 if the fruit has the property named in the\nrow, and a 0 if it does not. (This is your opinion, and may not\nagree with mine. That doesn't matter, as long as you follow through\nwith whatever your choices were.)\n \n\n\n(b) We'll define the dissimilarity between two fruits to be the\nnumber of qualities they *disagree* on. Thus, for example, the\ndissimilarity between Apple and Orange is 1 (an apple is crunchy and\nan orange is not, but they agree on everything else). Calculate the\ndissimilarity between each pair of fruits, and make a square table\nthat summarizes the results. (To save yourself some work, note that\nthe dissimilarity between a fruit and itself must be zero, and the\ndissimilarity between fruits A and B is the same as that between B\nand A.) Save your table of dissimilarities into a file for the next part.\n \n\n(c) Do a hierarchical cluster analysis using complete\nlinkage. Display your dendrogram.\n \n\n(d) How many clusters, of what fruits, do you seem to have?\nExplain briefly.\n \n\n(e) Pick a pair of clusters (with at least 2 fruits in each)\nfrom your dendrogram. Verify that \nthe complete-linkage distance on your dendrogram is correct.\n \n\n\n\n\n##  Similarity of species \n\n\n Two scientists assessed the dissimilarity\nbetween a number \nof species by recording the number of positions in the protein\nmolecule cytochrome-$c$ where the two species being compared have\ndifferent amino acids. The dissimilarities that they recorded are in\n[link](http://ritsokiguess.site/datafiles/species.txt).\n\n\n\n(a) Read the data into a data frame and take a look at it.\n\n\n\n(b) Bearing in mind that the values you read in are\n*already* dissimilarities, convert them into a `dist`\nobject suitable for running a cluster analysis on, and display the\nresults. (Note that you need to get rid of any columns that don't\ncontain numbers.)\n\n\n\n(c) Run a cluster analysis using single-linkage and obtain a dendrogram.\n\n\n\n(d) Run a cluster analysis using Ward's method and obtain a dendrogram.\n\n\n\n(e) Describe how the two dendrograms from the last two parts\nlook different.\n\n\n\n(f) Looking at your clustering for Ward's method, what seems to\nbe a sensible number of clusters? Draw boxes around those clusters.\n\n\n\n(g) List which cluster each species is in, for your preferred\nnumber of clusters (from Ward's method).\n\n\n\n\n\n\n\n##  Bridges in Pittsburgh\n\n\n The city of Pittsburgh, Pennsylvania, lies where three\nrivers, the Allegheny, Monongahela, and Ohio, \nmeet.^[For a long  time, the Pittsburgh Steelers football team played at the Three  Rivers Stadium.] \nIt has long been important to build bridges there,\nto enable its residents to cross the rivers safely. See\n[link](https://en.wikipedia.org/wiki/List_of_bridges_of_Pittsburgh) for\na listing (with pictures) of the bridges. The data at\n[link](https://raw.githubusercontent.com/nxskok/datafiles/master/bridges.csv) contains\ndetail for a large number of past and present bridges in\nPittsburgh. All the variables we will use are categorical. Here they\nare:\n\n\n\n* `id` identifying the bridge (we ignore)\n\n* `river`: initial letter of river that the bridge crosses\n\n* `location`: a numerical code indicating the location\nwithin Pittsburgh (we ignore)\n\n* `erected`: time period in which the bridge was built (a\nname, from `CRAFTS`, earliest, to `MODERN`, most\nrecent.\n\n* `purpose`: what the bridge carries: foot traffic\n(\"walk\"), water (aqueduct), road or railroad.\n\n* `length` categorized as long, medium or short.\n\n* `lanes` of traffic (or number of railroad tracks): a\nnumber, 1, 2, 4 or 6, that we will count as categorical.\n\n* `clear_g`: whether a vertical navigation requirement was\nincluded in the bridge design (that is, ships of a certain height\nhad to be able to get under the bridge). I think `G` means\n\"yes\". \n\n* `t_d`: method of construction. `DECK` means the\nbridge deck is on top of the construction, `THROUGH` means\nthat when you cross the bridge, some of the bridge supports are next\nto you or above you. \n\n* `material` the bridge is made of: iron, steel or wood.\n\n* `span`: whether the bridge covers a short, medium or long\ndistance. \n\n* `rel_l`: Relative length of the main span of the\nbridge (between the two central piers) to the total crossing length.\nThe categories are `S`, `S-F` and `F`. I don't\nknow what these mean.\n\n* `type` of bridge: wood, suspension, arch and three types\nof truss bridge: cantilever, continuous and simple.\n\n\nThe website [link](https://www.steelconstruction.info/Bridges) is an\nexcellent source of information about bridges. (That's where I learned\nthe difference between `THROUGH` and `DECK`.) Wikipedia\nalso has a good article at\n[link](https://en.wikipedia.org/wiki/Bridge). I also found\n[link](http://www.metaeventos.net/inscricoes/formularios_off/resumo_preenchido/DINCON/Pina-A_Colimodio-V_Silva-A_PinaFilho-A.pdf)\nwhich is the best description I've seen of the variables.\n\n\n\n(a) The bridges are stored in CSV format. Some of the\ninformation is not known and was recorded in the spreadsheet as\n`?`. Turn these into genuine missing values by adding\n`na=\"?\"` to your file-reading command. Display some of your\ndata, enough to see that you have some missing data.\n\n\n(b) Verify that there are missing values in this dataset. To see\nthem, convert the text columns temporarily to `factor`s using\n`mutate`, and pass the resulting data frame into\n`summary`.\n\n\n(c) Use `drop_na` to remove any rows of the data frame with missing values in them. How many rows do you have left?\n\n\n(d) We are going to assess the dissimilarity between two bridges\nby the number of the categorical variables they *disagree*\non. This is called a \"simple matching coefficient\", and is the\nsame thing we did in the question about clustering fruits based on\ntheir properties. This time, though, we want to count matches in\nthings that are *rows* of our data frame (properties of two\ndifferent bridges), so we will need to use a strategy like the one I\nused in calculating the Bray-Curtis distances.\nFirst, write a function that takes as input two vectors `v`\nand `w` and counts the number of their entries that differ\n(comparing the first with the first, the second with the second,\n\\ldots, the last with the last. I can think of a quick way and a\nslow way, but either way is good.) To test your function, create two\nvectors (using `c`) of the same length, and see whether it\ncorrectly counts the number of corresponding values that are\ndifferent. \n\n\n(e) Write a function that has as input two row numbers and a data\nframe to take those rows from. The function needs to select all the\ncolumns except for `id` and `location`, select the\nrows required one at a time, and turn them into vectors. (There may\nbe some repetitiousness here. That's OK.)  Then those two vectors\nare passed into the function you wrote in the previous part, and the\ncount of the number of differences is returned. This is like the\ncode in the Bray-Curtis problem. Test your function on rows 3 and 4\nof your bridges data set (with the missings removed). There should\nbe six variables that are different.\n\n\n(f) Create a matrix or data frame of pairwise dissimilarities\nbetween each pair of bridges (using only the ones with no missing\nvalues). Use loops, or `crossing` and `rowwise`, as\nyou prefer. Display the first six rows of\nyour matrix (using `head`) or the first few rows of your data\nframe. (The whole thing is big, so don't display it all.)\n\n\n(g) Turn your matrix or data frame into a `dist`\nobject. (If you couldn't create a matrix or data frame of\ndissimilarities, read them in from\n[link](https://raw.githubusercontent.com/nxskok/datafiles/master/mm.csv).) Do not\ndisplay your distance object.\n\n\n(h) Run a cluster analysis using Ward's method, and display a\ndendrogram. The labels for the bridges (rows of the data frame) may\ncome out too big; experiment with a `cex` less than 1 on the\nplot so that you can see them.\n\n\n(i) How many clusters do you think is reasonable for these\ndata? Draw them on your plot.\n\n\n(j) Pick three bridges in the same one of your clusters (it\ndoesn't matter which three bridges or which cluster). Display the\ndata for these bridges. Does it make sense that these three bridges\nended up in the same cluster? Explain briefly.\n\n\n\n\n\n\n\n\nMy solutions follow:\n\n\n\n\n##  Sites on the sea bed\n\n\n Biologists investigate the prevalence of\nspecies of organism by sampling sites where the organisms might be,\ntaking a \"grab\" from the site, and sending the grabs to a laboratory\nfor analysis. The data in this question come from the sea bed. There\nwere 30 sites, labelled `s1` through `s30`. At each\nsite, five species of organism, labelled `a` through\n`e`, were of interest; the data shown in those columns of the\ndata set were the number of organisms of that species identified in\nthe grab from that site. There are some other columns in the\n(original) data set that will not concern us. Our interest is in\nseeing which sites are similar to which other sites, so that a cluster\nanalysis will be suitable.\n\nWhen the data are counts of different species, as they are here,\nbiologists often measure the dissimilarity in species prevalence\nprofiles between two sites using something called the Bray-Curtis\ndissimilarity. It is not important to understand this for this\nquestion (though I explain it in my solutions). I calculated the\nBray-Curtis dissimilarity between each pair of sites and stored the\nresults in [link](http://ritsokiguess.site/datafiles/seabed1.csv). \n\n\n\n(a) Read in the dissimilarity data and check that you have 30\nrows and 30 columns of dissimilarities.\n\n\nSolution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/seabed1.csv\"\nseabed <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 30 Columns: 30\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\ndbl (30): s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, ...\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nseabed\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 x 30\n      s1    s2    s3    s4    s5    s6    s7    s8    s9   s10   s11   s12   s13\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 0     0.457 0.296 0.467 0.477 0.522 0.455 0.933 0.333 0.403 0.357 0.375 0.577\n 2 0.457 0     0.481 0.556 0.348 0.229 0.415 0.930 0.222 0.447 0.566 0.215 0.671\n 3 0.296 0.481 0     0.467 0.508 0.522 0.491 1     0.407 0.343 0.214 0.325 0.654\n 4 0.467 0.556 0.467 0     0.786 0.692 0.870 1     0.639 0.379 0.532 0.549 0.302\n 5 0.477 0.348 0.508 0.786 0     0.419 0.212 0.854 0.196 0.564 0.373 0.319 0.714\n 6 0.522 0.229 0.522 0.692 0.419 0     0.509 0.933 0.243 0.571 0.530 0.237 0.676\n 7 0.455 0.415 0.491 0.870 0.212 0.509 0     0.806 0.317 0.588 0.509 0.358 0.925\n 8 0.933 0.930 1     1     0.854 0.933 0.806 0     0.895 1     0.938 0.929 0.929\n 9 0.333 0.222 0.407 0.639 0.196 0.243 0.317 0.895 0     0.489 0.349 0.159 0.595\n10 0.403 0.447 0.343 0.379 0.564 0.571 0.588 1     0.489 0     0.449 0.419 0.415\n# i 20 more rows\n# i 17 more variables: s14 <dbl>, s15 <dbl>, s16 <dbl>, s17 <dbl>, s18 <dbl>,\n#   s19 <dbl>, s20 <dbl>, s21 <dbl>, s22 <dbl>, s23 <dbl>, s24 <dbl>,\n#   s25 <dbl>, s26 <dbl>, s27 <dbl>, s28 <dbl>, s29 <dbl>, s30 <dbl>\n```\n:::\n:::\n\n     \n\nCheck. The columns are labelled with\nthe site names. (As I originally set this question, the data file was\nread in with `read.csv` instead, and the site names were read\nin as row names as well: see discussion elsewhere about row names. But\nin the `tidyverse` we don't have row names.)\n    \n$\\blacksquare$\n\n(b) Create a distance object out of your dissimilarities,\nbearing in mind that the values are distances (well,\ndissimilarities) already.\n\n\nSolution\n\n\nThis one needs `as.dist` to convert already-distances into\na `dist` object. (`dist` would have\n*calculated* distances from things that were not\ndistances/dissimilarities yet.)\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- as.dist(seabed)\n```\n:::\n\n     \n\nIf you check, you'll see that the site names are being used to label\nrows *and* columns of the dissimilarity matrix as displayed. The\nlack of row names is not hurting us.\n    \n$\\blacksquare$\n\n(c) Fit a cluster analysis using single-linkage, and display a\ndendrogram of the results.\n\n\nSolution\n\n\nThis:\n\n::: {.cell}\n\n```{.r .cell-code}\nd.1 <- hclust(d, method = \"single\")\nplot(d.1)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-3-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n\nThis is a base-graphics plot, it not having any of the nice\n`ggplot` things. But it does the job.\n\nSingle-linkage tends to produce \"stringy\" clusters, since the\nindividual being added to a cluster only needs to be close to one\nthing in the cluster. Here, that manifests itself in sites getting\nadded to clusters one at a time: for example, sites 25 and 26 get\njoined together into a cluster, and then in sequence sites 6, 16, 27,\n30 and 22 get joined on to it (rather than any of those sites being\nformed into clusters first). \n\nYou might^[Conceivably.] be wondering what else is in that\n`hclust` object, and what it's good for. Let's take a look:\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(d.1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 7\n $ merge      : int [1:29, 1:2] -3 -25 -6 -9 -28 -16 -27 -1 -30 -24 ...\n $ height     : num [1:29] 0.1 0.137 0.152 0.159 0.159 ...\n $ order      : int [1:30] 21 14 29 23 15 1 19 18 2 7 ...\n $ labels     : chr [1:30] \"s1\" \"s2\" \"s3\" \"s4\" ...\n $ method     : chr \"single\"\n $ call       : language hclust(d = d, method = \"single\")\n $ dist.method: NULL\n - attr(*, \"class\")= chr \"hclust\"\n```\n:::\n:::\n\n \n\nYou might guess that `labels` contains the names of the sites,\nand you'd be correct. Of the other things, the most interesting are\n`merge` and `height`. Let's display them side by side:\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(d.1, cbind(height, merge))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         height        \n [1,] 0.1000000  -3 -20\n [2,] 0.1369863 -25 -26\n [3,] 0.1523179  -6   2\n [4,] 0.1588785  -9 -12\n [5,] 0.1588785 -28   4\n [6,] 0.1617647 -16   3\n [7,] 0.1633987 -27   6\n [8,] 0.1692308  -1 -19\n [9,] 0.1807229 -30   7\n[10,] 0.1818182 -24   5\n[11,] 0.1956522  -5  10\n[12,] 0.2075472 -15   8\n[13,] 0.2083333 -14 -29\n[14,] 0.2121212  -7  11\n[15,] 0.2142857 -11   1\n[16,] 0.2149533  -2  14\n[17,] 0.2191781 -18  16\n[18,] 0.2205882 -22   9\n[19,] 0.2285714  17  18\n[20,] 0.2307692  12  19\n[21,] 0.2328767 -10  15\n[22,] 0.2558140  20  21\n[23,] 0.2658228 -23  22\n[24,] 0.2666667  13  23\n[25,] 0.3023256  -4 -13\n[26,] 0.3333333  24  25\n[27,] 0.3571429 -21  26\n[28,] 0.4285714  -8 -17\n[29,] 0.6363636  27  28\n```\n:::\n:::\n\n \n\n`height` is the vertical scale of the dendrogram. The first\nheight is 0.1, and if you look at the bottom of the dendrogram, the\nfirst sites to be joined together are sites 3 and 20 at height 0.1\n(the horizontal bar joining sites 3 and 20 is what you are looking\nfor). In the last two columns, which came from `merge`, you see\nwhat got joined together, with negative numbers meaning individuals\n(individual sites), and positive numbers meaning clusters formed\nearlier. So, if you look at the third line, at height 0.152, site 6\ngets joined to the cluster formed on line 2, which (looking back) we\nsee consists of sites 25 and 26. Go back now to the dendrogram; about\n${3\\over 4}$ of the way across, you'll see sites 25 and 26 joined\ntogether into a cluster, and a little higher up the page, site 6 joins\nthat cluster.\n\nI said that single linkage produces stringy clusters, and the way that\nshows up in `merge` is that you often get an individual site\n(negative number) joined onto a previously-formed cluster (positive\nnumber). This is in contrast to Ward's method, below.\n    \n$\\blacksquare$\n\n(d) Now fit a cluster analysis using Ward's method, and display\na dendrogram of the results.\n\n\nSolution\n\n\nSame thing, with small changes. The hard part is getting the name \nof the `method` right:\n\n::: {.cell}\n\n```{.r .cell-code}\nd.2 <- hclust(d, method = \"ward.D\")\nplot(d.2, cex = 0.7)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \nThe site numbers were a bit close together, so I printed them out\nsmaller than usual size (which is what the `cex` and a number\nless than 1 is doing: 70\\% of normal size).^[This is base-graphics code, which I learned a long time ago. There are a lot of options with weird names that are hard to remember, and that are sometimes inconsistent with each other. There is a package `ggdendro` that makes nice `ggplot` dendrograms, and another called `dendextend` that does all kinds of stuff with dendrograms. I decided that it wasn't worth the trouble of teaching you (and therefore me) `ggdendro`, since the dendrograms look much the same.]\nThis time, there is a greater tendency for sites to be joined into\nsmall clusters first, then these small clusters are joined\ntogether. It's not perfect, but there is a greater tendency for it to\nhappen here.\n\nThis shows up in `merge` too:\n\n::: {.cell}\n\n```{.r .cell-code}\nd.2$merge\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2]\n [1,]   -3  -20\n [2,]  -25  -26\n [3,]   -9  -12\n [4,]  -28    3\n [5,]   -1  -19\n [6,]   -6    2\n [7,]  -14  -29\n [8,]   -5   -7\n [9,]  -18  -24\n[10,]  -27    6\n[11,]  -16  -22\n[12,]   -2    4\n[13,]  -30   10\n[14,]  -15    5\n[15,]  -23    8\n[16,]   -4  -13\n[17,]  -11    1\n[18,]    9   12\n[19,]  -10   17\n[20,]   -8  -17\n[21,]   11   13\n[22,]  -21   15\n[23,]    7   22\n[24,]   14   19\n[25,]   16   24\n[26,]   18   21\n[27,]   20   23\n[28,]   26   27\n[29,]   25   28\n```\n:::\n:::\n\n \n\nThere are relatively few instances of a site being joined to a cluster\nof sites. Usually, individual sites get joined together (negative with\na negative, mainly at the top of the list), or clusters get joined to\nclusters (positive with positive, mainly lower down the list).\n    \n$\\blacksquare$\n\n(e) <a name=\"part:prefclust\">*</a> On the Ward's method clustering, how many clusters would you\nchoose to divide the sites into? Draw rectangles around those clusters.\n\n\n\nSolution\n\n\nYou may need to draw the plot again. In any case, a second line of\ncode draws the rectangles. I think three clusters is good, but you\ncan have a few more than that if you like:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(d.2, cex = 0.7)\nrect.hclust(d.2, 3)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-8-1.pdf){fig-pos='H'}\n:::\n:::\n\n   \n\nWhat I want to see is a not-unreasonable choice of number of clusters\n(I think you could go up to about six), and then a depiction of that\nnumber of clusters on the plot. This is six clusters:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(d.2, cex = 0.7)\nrect.hclust(d.2, 6)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-9-1.pdf){fig-pos='H'}\n:::\n:::\n\n   \n\nIn all your plots, the `cex` is optional, but you can compare\nthe plots with it and without it and see which you prefer.\n\nLooking at this, even seven clusters might work, but I doubt you'd\nwant to go beyond that. The choice of the number of clusters is mainly\nan aesthetic^[This, I think, is the British spelling, with the  North American one being *esthetic*. My spelling is where the  *aes* in a *ggplot* comes from.] decision. \n\n  \n$\\blacksquare$\n\n(f) <a name=\"part:original\">*</a> The original data is in\n[link](http://ritsokiguess.site/datafiles/seabed.csv). Read in the\noriginal data and verify that you again have 30 sites, variables\ncalled `a` through `e` and some others.\n\n\n\nSolution\n\nThus:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/seabed.csv\"\nseabed.z <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 30 Columns: 10\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (2): site, sediment\ndbl (8): a, b, c, d, e, depth, pollution, temp\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nseabed.z\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 x 10\n   site      a     b     c     d     e depth pollution  temp sediment\n   <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n 1 s1        0     2     9    14     2    72       4.8   3.5 s       \n 2 s2       26     4    13    11     0    75       2.8   2.5 c       \n 3 s3        0    10     9     8     0    59       5.4   2.7 c       \n 4 s4        0     0    15     3     0    64       8.2   2.9 s       \n 5 s5       13     5     3    10     7    61       3.9   3.1 c       \n 6 s6       31    21    13    16     5    94       2.6   3.5 g       \n 7 s7        9     6     0    11     2    53       4.6   2.9 s       \n 8 s8        2     0     0     0     1    61       5.1   3.3 c       \n 9 s9       17     7    10    14     6    68       3.9   3.4 c       \n10 s10       0     5    26     9     0    69      10     3   s       \n# i 20 more rows\n```\n:::\n:::\n\n   \n\n30 observations of 10 variables, including `a` through\n`e`. Check.\n\nI gave this a weird name so that it didn't overwrite my original\n`seabed`, the one I turned into a distance object, though I\ndon't think I really needed to worry.\n\nThese data came from\n[link](http://www.fbbva.es/TLFU/dat/DE_2013_multivariate.pdf),^[If  you are a soccer fan, you might recognize BBVA as a former sponsor  of the top Spanish soccer league, *La Liga BBVA* (as it was). BBVA  is a Spanish bank that also has a Foundation that published this  book.] from which I also got the definition of the Bray-Curtis\ndissimilarity that I calculated for you. The data are in Exhibit 1.1\nof that book.\n\n  \n$\\blacksquare$\n\n(g) Go back to your Ward method dendrogram with the red\nrectangles and find two sites in the same cluster. Display the\noriginal data for your two sites and see if you can explain why they\nare in the same cluster. It doesn't matter which two sites you choose;\nthe grader will merely check that your results look reasonable.\n\n\n\nSolution\n\n\nI want my two sites to be very similar, so I'm looking at two sites\nthat were joined into a cluster very early on, sites `s3` and\n`s20`. As I said, I don't mind which ones you pick, but being\nin the same cluster will be easiest to justify if you pick sites\nthat were joined together early.\nThen you need to display just those rows of the original data (that\nyou just read in), which is a `filter` with an \"or\" in it:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>% filter(site == \"s3\" | site == \"s20\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 10\n  site      a     b     c     d     e depth pollution  temp sediment\n  <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n1 s3        0    10     9     8     0    59       5.4   2.7 c       \n2 s20       0    10    14     9     0    73       5.6   3   s       \n```\n:::\n:::\n\n   \n\nI think this odd-looking thing also works:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>% filter(site %in% c(\"s3\", \"s20\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 10\n  site      a     b     c     d     e depth pollution  temp sediment\n  <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n1 s3        0    10     9     8     0    59       5.4   2.7 c       \n2 s20       0    10    14     9     0    73       5.6   3   s       \n```\n:::\n:::\n\n \n\nI'll also take displaying the lines one at a time, though it is easier\nto compare them if they are next to each other.\n\nWhy are they in the same cluster? To be similar (that is, have a low\ndissimilarity), the values of `a` through `e` should be\nclose together. Here, they certainly are: `a` and `e`\nare both zero for both sites, and `b`, `c` and\n`d` are around 10 for both sites. So I'd call that similar. \n\nYou will probably pick a different pair of sites, and thus your\ndetailed discussion will differ from mine, but the general point of it\nshould be the same: pick a pair of sites in the same cluster,\ndisplay those two rows of the original data, some sensible\ndiscussion of how the sites are similar. As long as you pick\ntwo sites in the same one of your clusters, I don't mind which ones\nyou pick. The grader will check that your two sites were indeed in the\nsame one of your clusters, then will check that you do indeed display\nthose two sites from the original data.\n\nWhat happens if you pick sites from different clusters? Let's pick two\nvery dissimilar ones, sites 4 and 7 from opposite ends of my dendrogram:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>% filter(site == \"s4\" | site == \"s7\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 10\n  site      a     b     c     d     e depth pollution  temp sediment\n  <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n1 s4        0     0    15     3     0    64       8.2   2.9 s       \n2 s7        9     6     0    11     2    53       4.6   2.9 s       \n```\n:::\n:::\n\n \n\nSite `s4` has no `a` or `b` at all, and site\n`s7` has quite a few; site `s7` has no `c` at\nall, while site `s4` has a lot. These are very different sites.\n\nExtra: now that you've seen what the original data look like, I should\nexplain how I got the Bray-Curtis dissimilarities. As I said, only the\ncounts of species `a` through `e` enter into the\ncalculation; the other variables have nothing to do with it.\n\nLet's simplify matters by pretending that we have only two species (we\ncan call them A and B), and a vector like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(10, 3)\n```\n:::\n\n \n\nwhich says that we have 10 organisms of species A and 3 of species B\nat a site. This is rather similar to this site:\n\n::: {.cell}\n\n```{.r .cell-code}\nv2 <- c(8, 4)\n```\n:::\n\n \n\nbut very different from this site:\n\n::: {.cell}\n\n```{.r .cell-code}\nv3 <- c(0, 7)\n```\n:::\n\n \n\nThe way you calculate the Bray-Curtis dissimilarity is to take the\nabsolute difference of counts of organisms of each species:\n\n::: {.cell}\n\n```{.r .cell-code}\nabs(v1 - v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 1\n```\n:::\n:::\n\n \n\nand add those up:\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(abs(v1 - v2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n:::\n\n \n\nand then divide by the total of all the frequencies:\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(abs(v1 - v2)) / sum(v1 + v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.12\n```\n:::\n:::\n\n \n\nThe smaller this number is, the more similar the sites are. So you\nmight imagine that `v1` and `v3` would be more dissimilar:\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(abs(v1 - v3)) / sum(v1 + v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7\n```\n:::\n:::\n\n \n\nand so it is. The scaling of the Bray-Curtis dissimilarity is that the\nsmallest it can be is 0, if the frequencies of each of the species are\nexactly the same at the two sites, and the largest it can be is 1, if\none site has only species A and the other has only species B. (I'll\ndemonstrate that in a moment.)\nYou might imagine that we'll be doing this calculation a lot, and so\nwe should define a function to automate it. Hadley Wickham \n(in \"R for Data Science\") says that you should copy and paste some code (as\nI did above) no more than twice; if you need to do it again, you\nshould write a function instead. The thinking behind this is if you\ncopy and paste and change something (like a variable name), you'll\nneed to make the change *everywhere*, and it's so easy to miss\none. \nSo, my function is (copying and pasting my code from above into the\nbody of the function, which is Wickham-approved since it's only my\nsecond time):\n\n::: {.cell}\n\n```{.r .cell-code}\nbraycurtis <- function(v1, v2) {\n  sum(abs(v1 - v2)) / sum(v1 + v2)\n}\n```\n:::\n\n \n\nLet's test it on my made-up sites, making up one more:\n\n::: {.cell}\n\n```{.r .cell-code}\nbraycurtis(v1, v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.12\n```\n:::\n\n```{.r .cell-code}\nbraycurtis(v1, v3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7\n```\n:::\n\n```{.r .cell-code}\nbraycurtis(v2, v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nv4 <- c(4, 0)\nbraycurtis(v3, v4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n \n\nThese all check out. The first two are repeats of the ones we did\nbefore. The third one says that if you calculate Bray-Curtis for two\nsites with the exact same frequencies all the way along, you get the\nminimum value of 0; the fourth one says that when site `v3`\nonly has species B and site `v4` only has species A, you get\nthe maximum value of 1.\n\nBut note this:\n\n::: {.cell}\n\n```{.r .cell-code}\nv2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8 4\n```\n:::\n\n```{.r .cell-code}\n2 * v2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16  8\n```\n:::\n\n```{.r .cell-code}\nbraycurtis(v2, 2 * v2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3333333\n```\n:::\n:::\n\n \n\nYou might say that `v2` and `2*v2` are the same\ndistribution, and so they are, proportionately. But Bray-Curtis is\nassessing whether the frequencies are *the same* (as opposed to\nsomething like a chi-squared test that is assessing\nproportionality).^[You could make a table out of the sites and  species, and use the test statistic from a chi-squared test as a  measure of dissimilarity: the smallest it can be is zero, if the  species counts are exactly proportional at the two sites. It doesn't have an upper limit.]\n\nSo far so good. Now we have to do this for the actual data. The first\nissue^[There are more issues.]  is that the data is some of the\nrow of the original data frame; specifically, it's columns 2 through\n6. For example, sites `s3` and `s20` of the original\ndata frame look like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>% filter(site == \"s3\" | site == \"s20\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 10\n  site      a     b     c     d     e depth pollution  temp sediment\n  <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n1 s3        0    10     9     8     0    59       5.4   2.7 c       \n2 s20       0    10    14     9     0    73       5.6   3   s       \n```\n:::\n:::\n\n \n\nand we don't want to feed the whole of those into `braycurtis`,\njust the second through sixth elements of them. So let's write another\nfunction that extracts the columns `a` through `e` of its\ninputs for given rows, and passes those on to the `braycurtis`\nthat we wrote before. This is a little fiddly, but bear with me. The\ninput to the function is the data frame, then the two sites that we want:\nFirst, though, what happens if `filter` site `s3`?\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>% filter(site == \"s3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 10\n  site      a     b     c     d     e depth pollution  temp sediment\n  <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl> <dbl> <chr>   \n1 s3        0    10     9     8     0    59       5.4   2.7 c       \n```\n:::\n:::\n\n \nThis is a one-row data frame, not a vector as our function expects. \nDo we need to worry about it? First, grab the right columns, so that we will know what our function has to do:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>%\n  filter(site == \"s3\") %>%\n  select(a:e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 5\n      a     b     c     d     e\n  <dbl> <dbl> <dbl> <dbl> <dbl>\n1     0    10     9     8     0\n```\n:::\n:::\n\n \n\nThat leads us to this function, which is a bit repetitious, but for\ntwo repeats I can handle it. I haven't done anything about the fact\nthat `x` and `y` below are actually data frames:\n\n::: {.cell}\n\n```{.r .cell-code}\nbraycurtis.spec <- function(d, i, j) {\n  d %>% filter(site == i) %>% select(a:e) -> x\n  d %>% filter(site == j) %>% select(a:e) -> y\n  braycurtis(x, y)\n}\n```\n:::\n\n \nThe first time I did this, I had the `filter` and the\n`select` in the opposite order, so I was neatly *removing*\nthe column I wanted to `filter` by *before* I did the\n`filter`!\n\nThe first two lines pull out columns `a` through `e` of\n(respectively) sites `i` and `j`.\n\nIf I were going to create more than two things like `x` and\n`y`, I would have hived that off\ninto a separate function as well, but I didn't.\n\nSites 3 and 20 were the two sites I chose before as being similar ones (in the\nsame cluster). So the dissimilarity should be small:\n\n::: {.cell}\n\n```{.r .cell-code}\nbraycurtis.spec(seabed.z, \"s3\", \"s20\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n:::\n\n \n\nand so it is. Is it about right? The `c` differ by 5, the\n`d` differ by one, and the total frequency in both rows is\nabout 60, so the dissimilarity should be about $6/60=0.1$, as it is\n(exactly, in fact). \n\nThis, you will note, works. I think R has taken the attitude that it\ncan treat these one-row data frames as if they were vectors.\nThis is the cleaned-up version of my function. When I first wrote it,\nI `print`ed out `x` and `y`, so that I could\ncheck that they were what I was expecting (they were).^[I am a  paid-up member of the *print all the things* school of  debugging. You probably know how to do this better.]\nWe have almost all the machinery we need. Now what we have to do is to\ncompare every site with every other site and compute the dissimilarity\nbetween them. If you're used to Python or another similar language,\nyou'll recognize this as two loops, one inside the other. This can be done in R (and I'll show you how), but I'd rather show you the Tidyverse way first.\n\nThe starting point is to make a vector containing all the sites, which\nis easier than you would guess:\n\n::: {.cell}\n\n```{.r .cell-code}\nsites <- str_c(\"s\", 1:30)\nsites\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"s1\"  \"s2\"  \"s3\"  \"s4\"  \"s5\"  \"s6\"  \"s7\"  \"s8\"  \"s9\"  \"s10\" \"s11\" \"s12\"\n[13] \"s13\" \"s14\" \"s15\" \"s16\" \"s17\" \"s18\" \"s19\" \"s20\" \"s21\" \"s22\" \"s23\" \"s24\"\n[25] \"s25\" \"s26\" \"s27\" \"s28\" \"s29\" \"s30\"\n```\n:::\n:::\n\n \n\nNext, we need to make all possible *pairs* of sites, which we\nalso know how to do:^[You might be used to `datagrid` for this task, but that is better when you have fitted a model, and you are making combinations of things for prediction. Here we are not concerned about a model.]\n\n::: {.cell}\n\n```{.r .cell-code}\nsite_pairs <- crossing(site1 = sites, site2 = sites)\nsite_pairs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 900 x 2\n   site1 site2\n   <chr> <chr>\n 1 s1    s1   \n 2 s1    s10  \n 3 s1    s11  \n 4 s1    s12  \n 5 s1    s13  \n 6 s1    s14  \n 7 s1    s15  \n 8 s1    s16  \n 9 s1    s17  \n10 s1    s18  \n# i 890 more rows\n```\n:::\n:::\n\n \nNow, think about what to do in English first: \"for each of the sites in `site1`, and for each of the sites in `site2`, taken in parallel, work out the Bray-Curtis distance.\"  This is, I hope,\nmaking you think of `rowwise`:\n\n::: {.cell}\n\n```{.r .cell-code}\nsite_pairs %>%\n  rowwise() %>% \n  mutate(bray_curtis = braycurtis.spec(seabed.z, site1, site2)) -> bc\nbc\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 900 x 3\n# Rowwise: \n   site1 site2 bray_curtis\n   <chr> <chr>       <dbl>\n 1 s1    s1          0    \n 2 s1    s10         0.403\n 3 s1    s11         0.357\n 4 s1    s12         0.375\n 5 s1    s13         0.577\n 6 s1    s14         0.633\n 7 s1    s15         0.208\n 8 s1    s16         0.857\n 9 s1    s17         1    \n10 s1    s18         0.569\n# i 890 more rows\n```\n:::\n:::\n\n(you might notice that this takes a noticeable time to run.)\n\nThis is a \"long\" data frame, but for the cluster analysis, we need a wide one with sites in rows and columns, so let's create that:\n\n::: {.cell}\n\n```{.r .cell-code}\n(bc %>% pivot_wider(names_from=site2, values_from=bray_curtis) -> bc2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 30 x 31\n   site1    s1   s10   s11   s12   s13   s14   s15   s16   s17   s18   s19    s2\n   <chr> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 s1    0     0.403 0.357 0.375 0.577 0.633 0.208 0.857 1     0.569 0.169 0.457\n 2 s10   0.403 0     0.449 0.419 0.415 0.710 0.424 0.856 1     0.380 0.333 0.447\n 3 s11   0.357 0.449 0     0.463 0.481 0.765 0.491 0.66  1     0.627 0.343 0.566\n 4 s12   0.375 0.419 0.463 0     0.667 0.413 0.342 0.548 0.860 0.254 0.253 0.215\n 5 s13   0.577 0.415 0.481 0.667 0     1     0.608 0.875 1     0.667 0.524 0.671\n 6 s14   0.633 0.710 0.765 0.413 1     0     0.458 0.656 0.692 0.604 0.633 0.421\n 7 s15   0.208 0.424 0.491 0.342 0.608 0.458 0     0.856 0.733 0.548 0.25  0.375\n 8 s16   0.857 0.856 0.66  0.548 0.875 0.656 0.856 0     0.893 0.512 0.761 0.472\n 9 s17   1     1     1     0.860 1     0.692 0.733 0.893 0     0.914 0.905 0.862\n10 s18   0.569 0.380 0.627 0.254 0.667 0.604 0.548 0.512 0.914 0     0.449 0.315\n# i 20 more rows\n# i 18 more variables: s20 <dbl>, s21 <dbl>, s22 <dbl>, s23 <dbl>, s24 <dbl>,\n#   s25 <dbl>, s26 <dbl>, s27 <dbl>, s28 <dbl>, s29 <dbl>, s3 <dbl>, s30 <dbl>,\n#   s4 <dbl>, s5 <dbl>, s6 <dbl>, s7 <dbl>, s8 <dbl>, s9 <dbl>\n```\n:::\n:::\n\n \n\nThat's the data frame I shared with you.\n\nThe more Python-like way of doing it is a loop inside a loop. This\nworks in R, but it has more housekeeping and a few possibly unfamiliar\nideas. We are going to work with a `matrix`, and we access\nelements of a matrix with two numbers inside square brackets, a row\nnumber and a column number. We also have to initialize our matrix that\nwe're going to fill with Bray-Curtis distances; I'll fill it with $-1$\nvalues, so that if any are left at the end, I'll know I missed\nsomething.\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- matrix(-1, 30, 30)\nfor (i in 1:30) {\n  for (j in 1:30) {\n    m[i, j] <- braycurtis.spec(seabed.z, sites[i], sites[j])\n  }\n}\nrownames(m) <- sites\ncolnames(m) <- sites\nhead(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          s1        s2        s3        s4        s5        s6        s7\ns1 0.0000000 0.4567901 0.2962963 0.4666667 0.4769231 0.5221239 0.4545455\ns2 0.4567901 0.0000000 0.4814815 0.5555556 0.3478261 0.2285714 0.4146341\ns3 0.2962963 0.4814815 0.0000000 0.4666667 0.5076923 0.5221239 0.4909091\ns4 0.4666667 0.5555556 0.4666667 0.0000000 0.7857143 0.6923077 0.8695652\ns5 0.4769231 0.3478261 0.5076923 0.7857143 0.0000000 0.4193548 0.2121212\ns6 0.5221239 0.2285714 0.5221239 0.6923077 0.4193548 0.0000000 0.5087719\n          s8        s9       s10       s11       s12       s13       s14\ns1 0.9333333 0.3333333 0.4029851 0.3571429 0.3750000 0.5769231 0.6326531\ns2 0.9298246 0.2222222 0.4468085 0.5662651 0.2149533 0.6708861 0.4210526\ns3 1.0000000 0.4074074 0.3432836 0.2142857 0.3250000 0.6538462 0.6734694\ns4 1.0000000 0.6388889 0.3793103 0.5319149 0.5492958 0.3023256 0.8500000\ns5 0.8536585 0.1956522 0.5641026 0.3731343 0.3186813 0.7142857 0.2666667\ns6 0.9325843 0.2428571 0.5714286 0.5304348 0.2374101 0.6756757 0.5925926\n         s15       s16       s17       s18       s19       s20       s21\ns1 0.2075472 0.8571429 1.0000000 0.5689655 0.1692308 0.3333333 0.7333333\ns2 0.3750000 0.4720000 0.8620690 0.3146853 0.3695652 0.4022989 0.6666667\ns3 0.3584906 0.7346939 1.0000000 0.5344828 0.3230769 0.1000000 0.8222222\ns4 0.4090909 0.9325843 1.0000000 0.6635514 0.4642857 0.3333333 0.8333333\ns5 0.4687500 0.5045872 0.8095238 0.5118110 0.3947368 0.5211268 0.3571429\ns6 0.5357143 0.2484076 0.9111111 0.2571429 0.3870968 0.4621849 0.6730769\n         s22       s23       s24       s25       s26       s27       s28\ns1 0.7346939 0.4411765 0.5714286 0.7037037 0.6956522 0.6363636 0.3250000\ns2 0.3760000 0.5368421 0.2432432 0.3925926 0.3277311 0.3809524 0.2149533\ns3 0.6326531 0.5294118 0.3809524 0.6666667 0.6086957 0.6363636 0.5000000\ns4 0.9325843 0.8644068 0.5200000 0.9393939 0.9277108 0.9333333 0.5774648\ns5 0.3761468 0.2658228 0.4105263 0.5294118 0.4174757 0.3818182 0.3186813\ns6 0.2993631 0.4488189 0.3006993 0.1856287 0.1523179 0.2151899 0.2949640\n         s29       s30\ns1 0.4339623 0.6071429\ns2 0.3500000 0.3669065\ns3 0.4339623 0.5892857\ns4 0.5454545 0.8446602\ns5 0.3125000 0.4796748\ns6 0.5357143 0.2163743\n```\n:::\n:::\n\n \n\nBecause my loops work with site *numbers* and my function works\nwith site *names*, I have to remember to refer to the site names\nwhen I call my function. I also have to supply row and column names\n(the site names).\n\nThat looks all right. Are all my Bray-Curtis distances between 0 and 1? I can smoosh my matrix into a vector and summarize it:\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(as.vector(m))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.0000  0.3571  0.5023  0.5235  0.6731  1.0000 \n```\n:::\n:::\n\n \nAll the\ndissimilarities are correctly between 0 and 1. We can also check the\none we did before:\n\n::: {.cell}\n\n```{.r .cell-code}\nbc2 %>% filter(site1 == \"s3\") %>% select(s20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n    s20\n  <dbl>\n1   0.1\n```\n:::\n:::\n\n \n\nor\n\n::: {.cell}\n\n```{.r .cell-code}\nm[3, 20]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1\n```\n:::\n:::\n\n \n\nCheck.\n  \n$\\blacksquare$\n\n(h) Obtain the cluster memberships for each site, for your\npreferred number of clusters from part (<a href=\"#part:prefclust\">here</a>). Add a\ncolumn to the original data that you read in, in part\n(<a href=\"#part:original\">here</a>), containing those cluster memberships, *as a\nfactor*.  Obtain a plot that will enable you to assess the\nrelationship between those clusters and `pollution`. (Once you\nhave the cluster memberships, you can add them to the data frame and\nmake the graph using a pipe.)  What do you see?\n\n\n\nSolution\n\n\nStart by getting the clusters with `cutree`. I'm going with 3\nclusters, though you can use the number of clusters you chose\nbefore. (This is again making the grader's life a misery, but her\ninstructions from me are to check that you have done something\nreasonable, with the actual answer being less important.) \n\n::: {.cell}\n\n```{.r .cell-code}\ncluster <- cutree(d.2, 3)\ncluster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n s1  s2  s3  s4  s5  s6  s7  s8  s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 \n  1   2   1   1   3   2   3   3   2   1   1   2   1   3   1   2   3   2   1   1 \ns21 s22 s23 s24 s25 s26 s27 s28 s29 s30 \n  3   2   3   2   2   2   2   2   3   2 \n```\n:::\n:::\n\n \n\nNow, we add that to the original data, the data frame I called\n`seabed.z`, and make a plot. The best one is a boxplot:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>%\n  mutate(cluster = factor(cluster)) %>%\n  ggplot(aes(x = cluster, y = pollution)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-38-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nThe clusters differ substantially in terms of the amount of pollution,\nwith my cluster 1 being highest and my cluster 2 being\nlowest. (Cluster 3 has a low outlier.)\n\nAny sensible plot will do here. I think boxplots are the best, but you\ncould also do something like vertically-faceted histograms:\n\n::: {.cell}\n\n```{.r .cell-code}\nseabed.z %>%\n  mutate(cluster = factor(cluster)) %>%\n  ggplot(aes(x = pollution)) + geom_histogram(bins = 8) +\n  facet_grid(cluster ~ .)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-39-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nwhich to my mind doesn't show the differences as dramatically. (The bins are\ndetermined from all the data together, so that each facet actually has\nfewer than 8 bins. You can see where the bins would be if they had any\ndata in them.)\n\nHere's how 5 clusters looks:\n\n::: {.cell}\n\n```{.r .cell-code}\ncluster <- cutree(d.2, 5)\ncluster\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n s1  s2  s3  s4  s5  s6  s7  s8  s9 s10 s11 s12 s13 s14 s15 s16 s17 s18 s19 s20 \n  1   2   1   1   3   4   3   5   2   1   1   2   1   3   1   4   5   2   1   1 \ns21 s22 s23 s24 s25 s26 s27 s28 s29 s30 \n  3   4   3   2   4   4   4   2   3   4 \n```\n:::\n\n```{.r .cell-code}\nseabed.z %>%\n  mutate(cluster = factor(cluster)) %>%\n  ggplot(aes(x = cluster, y = pollution)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/seabed-40-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nThis time, the picture isn't quite so clear-cut, but clusters 1 and 5\nare the highest in terms of pollution and cluster 4 is the lowest. I'm\nguessing that whatever number of clusters you choose, you'll see some\ndifferences in terms of pollution.\n\nWhat is interesting is that `pollution` had *nothing* to\ndo with the original formation of the clusters: that was based only on\nwhich species were found at each site. So, what we have shown here is that\nthe amount of pollution has some association with what species are found at a\nsite. \n\nA way to go on with this is to use the clusters as \"known groups\"\nand predict the cluster membership from `depth`,\n`pollution` and `temp` using a discriminant\nanalysis. Then you could plot the sites, colour-coded by what cluster\nthey were in, and even though you had three variables, you could plot\nit in two dimensions (or maybe even one dimension, depending how many\nLD's were important). \n\n$\\blacksquare$  \n\n\n\n\n\n\n\n##  Dissimilarities between fruits\n\n\n Consider the fruits apple, orange, banana, pear,\nstrawberry, blueberry. We are going to work with these four\nproperties of fruits:\n\n\n* has a round shape\n\n* Is sweet\n\n* Is crunchy\n\n* Is a berry\n\n\n\n(a)  Make a table with fruits as columns, and with\nrows \"round shape\", \"sweet\", \"crunchy\", \"berry\". In each cell\nof the table, put a 1 if the fruit has the property named in the\nrow, and a 0 if it does not. (This is your opinion, and may not\nagree with mine. That doesn't matter, as long as you follow through\nwith whatever your choices were.)\n \nSolution\n\n\nSomething akin to this:\n\n\n```\n\nFruit        Apple Orange Banana Pear Strawberry Blueberry\nRound shape    1      1      0     0       0         1\nSweet          1      1      0     0       1         0\nCrunchy        1      0      0     1       0         0\nBerry          0      0      0     0       1         1\n\n```\n\nYou'll have to make a choice about \"crunchy\". I usually eat\npears before they're fully ripe, so to me, they're crunchy.\n \n$\\blacksquare$\n\n\n(b) We'll define the dissimilarity between two fruits to be the\nnumber of qualities they *disagree* on. Thus, for example, the\ndissimilarity between Apple and Orange is 1 (an apple is crunchy and\nan orange is not, but they agree on everything else). Calculate the\ndissimilarity between each pair of fruits, and make a square table\nthat summarizes the results. (To save yourself some work, note that\nthe dissimilarity between a fruit and itself must be zero, and the\ndissimilarity between fruits A and B is the same as that between B\nand A.) Save your table of dissimilarities into a file for the next part.\n \nSolution\n\n\nI got this, by counting them:\n\n```\n \nFruit         Apple  Orange   Banana   Pear  Strawberry  Blueberry\nApple           0       1       3       2        3          3\nOrange          1       0       2       3        2          2\nBanana          3       2       0       1        2          2\nPear            2       3       1       0        3          3\nStrawberry      3       2       2       3        0          2\nBlueberry       3       2       2       3        2          0\n\n```\n\nI copied this into a file `fruits.txt`. Note that (i) I\nhave aligned my columns, so that I will be able to use\n`read_table` later, and (ii) I have given the first column\na name, since `read_table` wants the same number of column\nnames as columns.\n\nExtra: yes, you can do this in R too. We've seen some of the tricks\nbefore. \n\nLet's start by reading in my table of fruits and properties, which\nI saved in\n[link](http://ritsokiguess.site/datafiles/fruit1.txt):\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/fruit1.txt\"\nfruit1 <- read_table(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n-- Column specification --------------------------------------------------------\ncols(\n  Property = col_character(),\n  Apple = col_double(),\n  Orange = col_double(),\n  Banana = col_double(),\n  Pear = col_double(),\n  Strawberry = col_double(),\n  Blueberry = col_double()\n)\n```\n:::\n\n```{.r .cell-code}\nfruit1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 7\n  Property    Apple Orange Banana  Pear Strawberry Blueberry\n  <chr>       <dbl>  <dbl>  <dbl> <dbl>      <dbl>     <dbl>\n1 Round.shape     1      1      0     0          0         1\n2 Sweet           1      1      0     0          1         0\n3 Crunchy         1      0      0     1          0         0\n4 Berry           0      0      0     0          1         1\n```\n:::\n:::\n\n     \n\nWe don't need the first column, so we'll get rid of it:\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit2 <- fruit1 %>% select(-Property)\nfruit2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 6\n  Apple Orange Banana  Pear Strawberry Blueberry\n  <dbl>  <dbl>  <dbl> <dbl>      <dbl>     <dbl>\n1     1      1      0     0          0         1\n2     1      1      0     0          1         0\n3     1      0      0     1          0         0\n4     0      0      0     0          1         1\n```\n:::\n:::\n\n \n\nThe loop way is the most direct. We're going to be looking at\ncombinations of fruits and other fruits, so we'll need two loops one\ninside the other. It's easier for this to work with column numbers,\nwhich here are 1 through 6, and we'll make a matrix `m` with\nthe dissimilarities in it, which we have to initialize first. I'll\ninitialize it to a $6\\times 6$ matrix of `-1`, since the final\ndissimilarities are 0 or bigger, and this way I'll know if I forgot\nanything.\n\nHere's where we are at so far:\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_m <- matrix(-1, 6, 6)\nfor (i in 1:6) {\n  for (j in 1:6) {\n    fruit_m[i, j] <- 3 # dissim between fruit i and fruit j\n  }\n}\n```\n:::\n\n \n\nThis, of course, doesn't run yet. The sticking point is how to\ncalculate the dissimilarity between two columns. I think that is a\nseparate thought process that should be in a function of its own. The\ninputs are the two column numbers, and a data frame to get those\ncolumns from:\n\n::: {.cell}\n\n```{.r .cell-code}\ndissim <- function(i, j, d) {\n  x <- d %>% select(i)\n  y <- d %>% select(j)\n  sum(x != y)\n}\ndissim(1, 2, fruit2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\ni Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(i)\n\n  # Now:\n  data %>% select(all_of(i))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using an external vector in selections was deprecated in tidyselect 1.1.0.\ni Please use `all_of()` or `any_of()` instead.\n  # Was:\n  data %>% select(j)\n\n  # Now:\n  data %>% select(all_of(j))\n\nSee <https://tidyselect.r-lib.org/reference/faq-external-vector.html>.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n \n\nApple and orange differ by one (not being crunchy). The process is:\ngrab the $i$-th column and call it `x`, grab the $j$-th column\nand call it `y`. These are two one-column data frames with four\nrows each (the four properties). `x!=y` goes down the rows, and\nfor each one gives a `TRUE` if they're different and a\n`FALSE` if they're the same. So `x!=y` is a collection\nof four T-or-F values. This seems backwards, but I was thinking of\nwhat we want to do: we want to count the number of different\nones. Numerically, `TRUE` counts as 1 and `FALSE` as 0,\nso we should make the thing we're counting (the different ones) come\nout as `TRUE`. To count the number of `TRUE`s (1s), add\nthem up. \n\nThat was a complicated thought process, so it was probably wise to\nwrite a function to do it. Now, in our loop, we only have to call the\nfunction (having put some thought into getting it right):\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_m <- matrix(-1, 6, 6)\nfor (i in 1:6) {\n  for (j in 1:6) {\n    fruit_m[i, j] <- dissim(i, j, fruit2)\n  }\n}\nfruit_m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6]\n[1,]    0    1    3    2    3    3\n[2,]    1    0    2    3    2    2\n[3,]    3    2    0    1    2    2\n[4,]    2    3    1    0    3    3\n[5,]    3    2    2    3    0    2\n[6,]    3    2    2    3    2    0\n```\n:::\n:::\n\n \n\nThe last step is re-associate the fruit names with this matrix. This\nis a `matrix` so it has a `rownames` and a\n`colnames`. We set both of those, but first we have to get the\nfruit names from `fruit2`:\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_names <- names(fruit2)\nrownames(fruit_m) <- fruit_names\ncolnames(fruit_m) <- fruit_names\nfruit_m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Apple Orange Banana Pear Strawberry Blueberry\nApple          0      1      3    2          3         3\nOrange         1      0      2    3          2         2\nBanana         3      2      0    1          2         2\nPear           2      3      1    0          3         3\nStrawberry     3      2      2    3          0         2\nBlueberry      3      2      2    3          2         0\n```\n:::\n:::\n\n \n\nThis is good to go into the cluster analysis (happening later).\n\nThere is a `tidyverse` way to do this also. It's actually a lot\nlike the loop way in its conception, but the coding looks\ndifferent. We start by making all combinations of the fruit names with\neach other, which is `crossing`:^[This is like `datagrid`, but without a model.]\n\n::: {.cell}\n\n```{.r .cell-code}\ncombos <- crossing(fruit = fruit_names, other = fruit_names)\ncombos\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 36 x 2\n   fruit  other     \n   <chr>  <chr>     \n 1 Apple  Apple     \n 2 Apple  Banana    \n 3 Apple  Blueberry \n 4 Apple  Orange    \n 5 Apple  Pear      \n 6 Apple  Strawberry\n 7 Banana Apple     \n 8 Banana Banana    \n 9 Banana Blueberry \n10 Banana Orange    \n# i 26 more rows\n```\n:::\n:::\n\n \n\nNow, we want a function that, given any two fruit *names*, works\nout the dissimilarity between them. A happy coincidence is that we can\nuse the function we had before, *unmodified*! How? Take a look: \n\n::: {.cell}\n\n```{.r .cell-code}\ndissim <- function(i, j, d) {\n  x <- d %>% select(i)\n  y <- d %>% select(j)\n  sum(x != y)\n}\ndissim(\"Apple\", \"Orange\", fruit2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n```\n:::\n:::\n\n \n\n`select` can take a column number *or a column name*, so\nthat running it with column names gives the right answer.\n\nNow, we want to run this function for each of the pairs in\n`combos`. This is `rowwise`, since our function takes only one `fruit` and one `other` fruit at a time, not all of them at once:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombos %>% \n  rowwise() %>% \n  mutate(dissim = dissim(fruit, other, fruit2))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 36 x 3\n# Rowwise: \n   fruit  other      dissim\n   <chr>  <chr>       <int>\n 1 Apple  Apple           0\n 2 Apple  Banana          3\n 3 Apple  Blueberry       3\n 4 Apple  Orange          1\n 5 Apple  Pear            2\n 6 Apple  Strawberry      3\n 7 Banana Apple           3\n 8 Banana Banana          0\n 9 Banana Blueberry       2\n10 Banana Orange          2\n# i 26 more rows\n```\n:::\n:::\n\n \n\nThis would work just as well using `fruit1`, with the column of properties, rather than\n`fruit2`, since we are picking out the columns by name rather\nthan number.\n\nTo make this into something we can turn into a `dist` object\nlater, we need to pivot-wider the column `other` to make a\nsquare array:\n\n::: {.cell}\n\n```{.r .cell-code}\ncombos %>% \n  rowwise() %>% \n  mutate(dissim = dissim(fruit, other, fruit2)) %>% \n  pivot_wider(names_from = other, values_from = dissim) -> fruit_spread\nfruit_spread\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 7\n  fruit      Apple Banana Blueberry Orange  Pear Strawberry\n  <chr>      <int>  <int>     <int>  <int> <int>      <int>\n1 Apple          0      3         3      1     2          3\n2 Banana         3      0         2      2     1          2\n3 Blueberry      3      2         0      2     3          2\n4 Orange         1      2         2      0     3          2\n5 Pear           2      1         3      3     0          3\n6 Strawberry     3      2         2      2     3          0\n```\n:::\n:::\n\n \n\nDone!\n \n$\\blacksquare$ \n\n(c) Do a hierarchical cluster analysis using complete\nlinkage. Display your dendrogram.\n \nSolution\n\n\nFirst, we need to take one of our matrices of dissimilarities\nand turn it into a `dist` object. Since I asked you to\nsave yours into a file, let's start from there. Mine is aligned\ncolumns: \n\n::: {.cell}\n\n```{.r .cell-code}\ndissims <- read_table(\"fruits.txt\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\n-- Column specification --------------------------------------------------------\ncols(\n  fruit = col_character(),\n  Apple = col_double(),\n  Orange = col_double(),\n  Banana = col_double(),\n  Pear = col_double(),\n  Strawberry = col_double(),\n  Blueberry = col_double()\n)\n```\n:::\n\n```{.r .cell-code}\ndissims\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 7\n  fruit      Apple Orange Banana  Pear Strawberry Blueberry\n  <chr>      <dbl>  <dbl>  <dbl> <dbl>      <dbl>     <dbl>\n1 Apple          0      1      3     2          3         3\n2 Orange         1      0      2     3          2         2\n3 Banana         3      2      0     1          2         2\n4 Pear           2      3      1     0          3         3\n5 Strawberry     3      2      2     3          0         2\n6 Blueberry      3      2      2     3          2         0\n```\n:::\n:::\n\n      \n\nThen turn it into a `dist` object. The first step is to take\noff the first column, since `as.dist` can get the names from\nthe columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndissims %>%\n  select(-fruit) %>%\n  as.dist() -> d\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           Apple Orange Banana Pear Strawberry\nOrange         1                              \nBanana         3      2                       \nPear           2      3      1                \nStrawberry     3      2      2    3           \nBlueberry      3      2      2    3          2\n```\n:::\n:::\n\n\n\nIf you forget to take off the first column, this happens:\n\n::: {.cell}\n\n```{.r .cell-code}\nas.dist(dissims)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in storage.mode(m) <- \"numeric\": NAs introduced by coercion\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in as.dist.default(dissims): non-square matrix\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nError in dimnames(df) <- if (is.null(labels)) list(seq_len(size), seq_len(size)) else list(labels, : length of 'dimnames' [1] not equal to array extent\n```\n:::\n:::\n\n \n\nYou have one more column\nthan you have rows, since you have a column of fruit names. \n\nAside: what is that stuff about `dimnames`?\n\n::: {.cell}\n\n```{.r .cell-code}\ndimnames(dissims)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] \"1\" \"2\" \"3\" \"4\" \"5\" \"6\"\n\n[[2]]\n[1] \"fruit\"      \"Apple\"      \"Orange\"     \"Banana\"     \"Pear\"      \n[6] \"Strawberry\" \"Blueberry\" \n```\n:::\n:::\n\nDataframes have column names (the second element of that list), literally the names of the columns. But they can also have \"row names\". This is more part of the old-fashioned `data.frame` thinking, because in the tidyverse, row names are ignored. If your dataframe doesn't explicitly have row names (ours doesn't), the values 1 through the number of rows are used instead. If you like to think of it this way, a dataframe has two dimensions (rows and columns), and so `dimnames` for a dataframe is a list of length two.\n\nNow, to that error message. A `dist` object is square (well, half of a square, as it displays), so if you use `as.dist` to make it from a dataframe, that dataframe had better be square as well. The way `as.dist` checks your dataframe for squareness is to see whether it has the same number of rows as columns, and the way it does *that* is to look at its `dimnames` and checks whether they have the same length. Here, there are six row names but seven^[Count them.] column names. Hence the error message.\n\nThere is, I suppose, one more thing to say: internally, a dataframe is a `list` of columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndissims %>% as.list()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$fruit\n[1] \"Apple\"      \"Orange\"     \"Banana\"     \"Pear\"       \"Strawberry\"\n[6] \"Blueberry\" \n\n$Apple\n[1] 0 1 3 2 3 3\n\n$Orange\n[1] 1 0 2 3 2 2\n\n$Banana\n[1] 3 2 0 1 2 2\n\n$Pear\n[1] 2 3 1 0 3 3\n\n$Strawberry\n[1] 3 2 2 3 0 2\n\n$Blueberry\n[1] 3 2 2 3 2 0\n\nattr(,\"spec\")\ncols(\n  fruit = col_character(),\n  Apple = col_double(),\n  Orange = col_double(),\n  Banana = col_double(),\n  Pear = col_double(),\n  Strawberry = col_double(),\n  Blueberry = col_double()\n)\n```\n:::\n:::\n\nSince there are seven columns, this dataframe has seven \"things\" in it. This is the \"array extent\" that the error message talks about. But the first thing in `dimnames`, the row names, which the error message calls `'dimnames' [1]`, only has six things in it. End of aside.\n\nThis one is `as.dist` rather than `dist` since you already have dissimilarities\nand you want to arrange them into the right type of\nthing. `dist` is for *calculating* dissimilarities, which\nwe did before, so we don't want to do that now.\n\nNow, after all that work, the actual cluster analysis and dendrogram:\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits.1 <- hclust(d, method = \"complete\")\nplot(fruits.1)\nrect.hclust(fruits.1, 3)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/hkadh-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n$\\blacksquare$ \n\n(d) How many clusters, of what fruits, do you seem to have?\nExplain briefly.\n \nSolution\n\n\nI reckon I have three clusters: strawberry and blueberry in one,\napple and orange in the second, and banana and pear in the\nthird. (If your dissimilarities were different from mine, your\ndendrogram will be different also.)\n \n$\\blacksquare$\n\n(e) Pick a pair of clusters (with at least 2 fruits in each)\nfrom your dendrogram. Verify that \nthe complete-linkage distance on your dendrogram is correct.\n \nSolution\n\n\nI'll pick strawberry-blueberry and and apple-orange. I'll arrange\nthe dissimilarities like this:\n\n```\n\n           apple   orange\nstrawberry    3       2\nblueberry     3       2\n\n```\n\nThe largest of those is 3, so that's the complete-linkage\ndistance. That's also what the dendrogram says.\n(Likewise, the smallest of those is 2, so 2 is the\nsingle-linkage distance.) That is to say, the largest distance or\ndissimilarity \nfrom anything in one cluster to anything in the other is 3, and\nthe smallest is 2.\nI don't mind which pair of clusters you take, as long as you spell\nout the dissimilarity (distance) between each fruit in each\ncluster, and take the maximum of those. Besides, if your\ndissimilarities are different from mine, your complete-linkage\ndistance could be different from mine also. The grader will have\nto use her judgement!^[That's two cups of coffee I owe the      grader now.]  \n\nThe important point is that you assess the dissimilarities between\nfruits in one cluster and fruits in the other. The dissimilarities\nbetween fruits in the same cluster don't enter into it.^[I now have a mental image of John Cleese saying \"it don't enter      into it\" in the [infamous Dead Parrot sketch](https://www.youtube.com/watch?v=vnciwwsvNcc). Not to      mention       [How to defend yourself against an assailant armed with fresh      fruit](https://www.youtube.com/watch?v=4JgbOkLdRaE.)]\nAs it happens, all my complete-linkage distances between clusters\n(of at least 2 fruits) are 3. The single-linkage ones are\ndifferent, though:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruits.2 <- hclust(d, method = \"single\")\nplot(fruits.2)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/lhsdjhad-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n\nAll the single-linkage cluster distances are 2. (OK, so this wasn't a\nvery interesting example, but I wanted to give you one where you could\ncalculate what was going on.)\n \n$\\blacksquare$\n\n\n\n\n##  Similarity of species \n\n\n Two scientists assessed the dissimilarity\nbetween a number \nof species by recording the number of positions in the protein\nmolecule cytochrome-$c$ where the two species being compared have\ndifferent amino acids. The dissimilarities that they recorded are in\n[link](http://ritsokiguess.site/datafiles/species.txt).\n\n\n\n(a) Read the data into a data frame and take a look at it.\n\n\nSolution\n\n\nNothing much new here:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/species.txt\"\nspecies <- read_delim(my_url, \" \")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 8 Columns: 9\n-- Column specification --------------------------------------------------------\nDelimiter: \" \"\nchr (1): what\ndbl (8): Man, Monkey, Horse, Pig, Pigeon, Tuna, Mould, Fungus\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nspecies\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 9\n  what     Man Monkey Horse   Pig Pigeon  Tuna Mould Fungus\n  <chr>  <dbl>  <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl>  <dbl>\n1 Man        0      1    17    13     16    31    63     66\n2 Monkey     1      0    16    12     15    32    62     65\n3 Horse     17     16     0     5     16    27    64     68\n4 Pig       13     12     5     0     13    25    64     67\n5 Pigeon    16     15    16    13      0    27    59     66\n6 Tuna      31     32    27    25     27     0    72     69\n7 Mould     63     62    64    64     59    72     0     61\n8 Fungus    66     65    68    67     66    69    61      0\n```\n:::\n:::\n\n     \n\nThis is a square array of dissimilarities between the eight species.\n\nThe data set came from the 1960s, hence the use of \"Man\" rather than\n\"human\". It probably also came from the UK, judging by the spelling\nof `Mould`.\n\n(I gave the first column the name `what` so that you could\nsafely use `species` for the whole data frame.)\n    \n$\\blacksquare$\n\n(b) Bearing in mind that the values you read in are\n*already* dissimilarities, convert them into a `dist`\nobject suitable for running a cluster analysis on, and display the\nresults. (Note that you need to get rid of any columns that don't\ncontain numbers.)\n\n\nSolution\n\n\nThe point here is that the values you have are *already*\ndissimilarities, so no conversion of the numbers is required. Thus\nthis is a job for `as.dist`, which merely changes how it\nlooks. Use a pipeline to get rid of the first column first:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies %>%\n  select(-what) %>%\n  as.dist() -> d\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Man Monkey Horse Pig Pigeon Tuna Mould\nMonkey   1                                   \nHorse   17     16                            \nPig     13     12     5                      \nPigeon  16     15    16  13                  \nTuna    31     32    27  25     27           \nMould   63     62    64  64     59   72      \nFungus  66     65    68  67     66   69    61\n```\n:::\n:::\n\n\n\nThis doesn't display anything that it doesn't need to: we know that the\ndissimilarity between a species and itself is zero (no need to show\nthat), and that the dissimilarity between B and A is the same as\nbetween A and B, so no need to show everything twice. It might look as\nif you are missing a row and a column, but one of the species (Fungus)\nappears only in a row and one of them (Man) only in a column.\n\nThis also works, to select only the numerical columns:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies %>%\n  select(where(is.numeric)) %>%\n  as.dist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       Man Monkey Horse Pig Pigeon Tuna Mould\nMonkey   1                                   \nHorse   17     16                            \nPig     13     12     5                      \nPigeon  16     15    16  13                  \nTuna    31     32    27  25     27           \nMould   63     62    64  64     59   72      \nFungus  66     65    68  67     66   69    61\n```\n:::\n:::\n\n \n\nExtra: data frames officially have an attribute called \"row names\",\nthat is displayed where the row numbers display, but which isn't\nactually a column of the data frame. In the past, when we used\n`read.table` with a dot, the first column of data read in from\nthe file could be nameless (that is, you could have one more column of\ndata than you had column names) and the first column would be treated\nas row names. People used row names for things like identifier\nvariables. But row names have this sort of half-existence, and when\nHadley Wickham designed the `tidyverse`, he decided not to use\nrow names, taking the attitude that if it's part of the data, it\nshould be in the data frame as a genuine column. This means that when\nyou use a `read_` function, you have to have exactly as many\ncolumn names as columns. \n\nFor these data, I previously had the column here called\n`what` as row names, and `as.dist` automatically got rid\nof the row names when formatting the distances. Now, it's a\ngenuine column, so I have to get rid of it before running\n`as.dist`. This is more work, but it's also more honest, and\ndoesn't involve thinking about row names at all. So, on balance, I\nthink it's a win.\n  \n$\\blacksquare$\n\n(c) Run a cluster analysis using single-linkage and obtain a dendrogram.\n\n\nSolution\n\n\nSomething like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies.1 <- hclust(d, method = \"single\")\nplot(species.1)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/species-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n    \n$\\blacksquare$\n\n(d) Run a cluster analysis using Ward's method and obtain a dendrogram.\n\n\nSolution\n\n\nNot much changes  here in the code, but the result is noticeably\ndifferent:\n\n::: {.cell}\n\n```{.r .cell-code}\nspecies.2 <- hclust(d, method = \"ward.D\")\nplot(species.2)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/species-5-1.pdf){fig-pos='H'}\n:::\n:::\n\n  \n\nDon't forget to take care with the `method`: it has to be\n`ward` in lowercase (even though it's someone's name) followed\nby a D in uppercase.\n\n    \n$\\blacksquare$\n\n(e) Describe how the two dendrograms from the last two parts\nlook different.\n\n\nSolution\n\n\nThis is (as ever with this kind of thing) a judgement call. Your\njob is to come up with something reasonable.\nFor myself, I was thinking about how single-linkage tends to\nproduce \"stringy\" clusters that join single objects (species)\nonto already-formed clusters. Is that happening here? Apart from\nthe first two clusters, man and monkey, horse and pig,\n*everything* that gets joined on is a single species joined\non to a bigger cluster, including mould and fungus right at the\nend. Contrast that with the output from Ward's method, where, for\nthe most part, groups are formed first and then joined onto other\ngroups. For example, in Ward's method, mould and fungus are joined\nearlier, and also the man-monkey group is joined to the\npigeon-horse-pig group.^[Tuna is an exception, but usually Ward    tends to join fairly dissimilar things that are nonetheless more    similar to each other than to anything else. This is like    Hungarian and Finnish in the example in lecture: they are very    dissimilar languages, but they are more similar to each other than    to anything else.]\nYou might prefer to look at the specifics of what gets joined. I\nthink the principal difference from this angle is that mould and\nfungus get joined together (much) earlier in Ward. Also, pigeon\ngets joined to horse and pig first under Ward, but *after*\nthose have been joined to man and monkey under\nsingle-linkage. This is also a reasonable kind of observation.\n    \n$\\blacksquare$\n\n(f) Looking at your clustering for Ward's method, what seems to\nbe a sensible number of clusters? Draw boxes around those clusters.\n\n\nSolution\n\n\nPretty much any number of clusters bigger than 1 and smaller than\n8 is ok here, but I would prefer to see something between 2 and\n5, because a number of clusters of that sort offers (i) some\ninsight (\"these things are like these other things\") and (ii) a\nnumber of clusters of that sort is supported by the data.\nTo draw those clusters, you need `rect.hclust`, and\nbefore that you'll need to plot the cluster object again. For 2\nclusters, that would look like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(species.2)\nrect.hclust(species.2, 2)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/species-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nThis one is \"mould and fungus vs. everything else\". (My red boxes\nseem to have gone off the side, sorry.)\n\nOr we could go to the other end of the scale:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(species.2)\nrect.hclust(species.2, 5)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/species-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nFive is not really an insightful number of clusters with 8 species,\nbut it seems to correspond (for me at least) with a reasonable\ndivision of these species into \"kinds of living things\". That is, I\nam bringing some outside knowledge into my number-of-clusters division.\n    \n$\\blacksquare$\n\n(g) List which cluster each species is in, for your preferred\nnumber of clusters (from Ward's method).\n\n\nSolution\n\n\nThis is `cutree`. For 2 clusters it would be this:\n\n::: {.cell}\n\n```{.r .cell-code}\ncutree(species.2, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Man Monkey  Horse    Pig Pigeon   Tuna  Mould Fungus \n     1      1      1      1      1      1      2      2 \n```\n:::\n:::\n\n     \n\nFor 5 it would be this:\n\n::: {.cell}\n\n```{.r .cell-code}\ncutree(species.2, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Man Monkey  Horse    Pig Pigeon   Tuna  Mould Fungus \n     1      1      2      2      2      3      4      5 \n```\n:::\n:::\n\n \n\nand anything in between is in between. \n\nThese ones came out sorted, so there is no need to sort them (so you\ndon't need the methods of the next question).\n    \n$\\blacksquare$\n\n\n\n\n\n##  Bridges in Pittsburgh\n\n\n The city of Pittsburgh, Pennsylvania, lies where three\nrivers, the Allegheny, Monongahela, and Ohio, \nmeet.^[For a long  time, the Pittsburgh Steelers football team played at the Three  Rivers Stadium.] \nIt has long been important to build bridges there,\nto enable its residents to cross the rivers safely. See\n[link](https://en.wikipedia.org/wiki/List_of_bridges_of_Pittsburgh) for\na listing (with pictures) of the bridges. The data at\n[link](https://raw.githubusercontent.com/nxskok/datafiles/master/bridges.csv) contains\ndetail for a large number of past and present bridges in\nPittsburgh. All the variables we will use are categorical. Here they\nare:\n\n\n\n* `id` identifying the bridge (we ignore)\n\n* `river`: initial letter of river that the bridge crosses\n\n* `location`: a numerical code indicating the location\nwithin Pittsburgh (we ignore)\n\n* `erected`: time period in which the bridge was built (a\nname, from `CRAFTS`, earliest, to `MODERN`, most\nrecent.\n\n* `purpose`: what the bridge carries: foot traffic\n(\"walk\"), water (aqueduct), road or railroad.\n\n* `length` categorized as long, medium or short.\n\n* `lanes` of traffic (or number of railroad tracks): a\nnumber, 1, 2, 4 or 6, that we will count as categorical.\n\n* `clear_g`: whether a vertical navigation requirement was\nincluded in the bridge design (that is, ships of a certain height\nhad to be able to get under the bridge). I think `G` means\n\"yes\". \n\n* `t_d`: method of construction. `DECK` means the\nbridge deck is on top of the construction, `THROUGH` means\nthat when you cross the bridge, some of the bridge supports are next\nto you or above you. \n\n* `material` the bridge is made of: iron, steel or wood.\n\n* `span`: whether the bridge covers a short, medium or long\ndistance. \n\n* `rel_l`: Relative length of the main span of the\nbridge (between the two central piers) to the total crossing length.\nThe categories are `S`, `S-F` and `F`. I don't\nknow what these mean.\n\n* `type` of bridge: wood, suspension, arch and three types\nof truss bridge: cantilever, continuous and simple.\n\n\nThe website [link](https://www.steelconstruction.info/Bridges) is an\nexcellent source of information about bridges. (That's where I learned\nthe difference between `THROUGH` and `DECK`.) Wikipedia\nalso has a good article at\n[link](https://en.wikipedia.org/wiki/Bridge). I also found\n[link](http://www.metaeventos.net/inscricoes/formularios_off/resumo_preenchido/DINCON/Pina-A_Colimodio-V_Silva-A_PinaFilho-A.pdf)\nwhich is the best description I've seen of the variables.\n\n\n\n(a) The bridges are stored in CSV format. Some of the\ninformation is not known and was recorded in the spreadsheet as\n`?`. Turn these into genuine missing values by adding\n`na=\"?\"` to your file-reading command. Display some of your\ndata, enough to see that you have some missing data.\n\nSolution\n\n\nThis sort of thing:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"https://raw.githubusercontent.com/nxskok/datafiles/master/bridges.csv\"\nbridges0 <- read_csv(my_url, na = \"?\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 108 Columns: 13\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (11): id, river, erected, purpose, length, clear_g, t_d, material, span,...\ndbl  (2): location, lanes\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nbridges0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 108 x 13\n   id    river location erected purpose  length lanes clear_g t_d     material\n   <chr> <chr>    <dbl> <chr>   <chr>    <chr>  <dbl> <chr>   <chr>   <chr>   \n 1 E1    M            3 CRAFTS  HIGHWAY  <NA>       2 N       THROUGH WOOD    \n 2 E2    A           25 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 3 E3    A           39 CRAFTS  AQUEDUCT <NA>       1 N       THROUGH WOOD    \n 4 E5    A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 5 E6    M           23 CRAFTS  HIGHWAY  <NA>       2 N       THROUGH WOOD    \n 6 E7    A           27 CRAFTS  HIGHWAY  SHORT      2 N       THROUGH WOOD    \n 7 E8    A           28 CRAFTS  AQUEDUCT MEDIUM     1 N       THROUGH IRON    \n 8 E9    M            3 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH IRON    \n 9 E10   A           39 CRAFTS  AQUEDUCT <NA>       1 N       DECK    WOOD    \n10 E11   A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n# i 98 more rows\n# i 3 more variables: span <chr>, rel_l <chr>, type <chr>\n```\n:::\n:::\n\n \n\nI have some missing values in the `length` column. (You\nsometimes see `<NA>` instead of `NA`, as you do here;\nthis means the missing value is a missing piece of text rather than a\nmissing number.)^[Sometimes it's necessary to distinguish  between the different types of missing value; if that's the case,  you can use eg. `NA_real_` and `NA_character_-` to distinguish missing decimal numbers from missing text.]\n\nThere are 108 bridges in the data set.\n\nI'm saving the name `bridges` for my final data set, after I'm\nfinished organizing it.\n\n$\\blacksquare$\n\n(b) Verify that there are missing values in this dataset. To see\nthem, convert the text columns temporarily to `factor`s using\n`mutate`, and pass the resulting data frame into\n`summary`.\n\nSolution\n\n\nI called my data frame `bridges0`, so this:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges0 %>%\n  mutate(across(where(is.character), \\(x) factor(x))) %>%\n  summary()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n       id      river     location         erected       purpose      length  \n E1     :  1   A:49   Min.   : 1.00   CRAFTS  :18   AQUEDUCT: 4   LONG  :21  \n E10    :  1   M:41   1st Qu.:15.50   EMERGING:15   HIGHWAY :71   MEDIUM:48  \n E100   :  1   O:15   Median :27.00   MATURE  :54   RR      :32   SHORT :12  \n E101   :  1   Y: 3   Mean   :25.98   MODERN  :21   WALK    : 1   NA's  :27  \n E102   :  1          3rd Qu.:37.50                                          \n E103   :  1          Max.   :52.00                                          \n (Other):102          NA's   :1                                              \n     lanes      clear_g        t_d      material      span     rel_l   \n Min.   :1.00   G   :80   DECK   :15   IRON :11   LONG  :30   F   :58  \n 1st Qu.:2.00   N   :26   THROUGH:87   STEEL:79   MEDIUM:53   S   :30  \n Median :2.00   NA's: 2   NA's   : 6   WOOD :16   SHORT : 9   S-F :15  \n Mean   :2.63                          NA's : 2   NA's  :16   NA's: 5  \n 3rd Qu.:4.00                                                          \n Max.   :6.00                                                          \n NA's   :16                                                            \n       type   \n SIMPLE-T:44  \n WOOD    :16  \n ARCH    :13  \n CANTILEV:11  \n SUSPEN  :11  \n (Other) :11  \n NA's    : 2  \n```\n:::\n:::\n\n   \n\nThere are missing values all over the place. `length` has the\nmost, but `lanes` and `span` also have a fair few.\n\n`mutate` requires `across` and a logical condition, something that is true or false, about each column, and then something to do with it.\nIn words, \"for each column that is text, replace it (temporarily) with the factor version of itself.\"\n\nExtra: I think the reason `summary` doesn't handle text stuff very\nwell is that, originally, text columns that were read in from files\n*got turned into* factors, and if you didn't want that to happen,\nyou had to explicitly stop it yourself. Try mentioning\n`stringsAsFactors=F` to a veteran R user, and watch their\nreaction, or try it yourself by reading in a data file with text\ncolumns using `read.table` instead of\n`read_delim`. (This will read in an old-fashioned data frame,\nso pipe it through `as_tibble` to see what the columns are.)\n\nWhen Hadley Wickham designed `readr`, the corner of the\n`tidyverse` where the `read_` functions live, he\ndeliberately chose to keep text as text (on the basis of being honest\nabout what kind of thing we have), with the result that we sometimes\nhave to create factors when what we are using requires them rather\nthan text.\n\n$\\blacksquare$\n\n(c) Use `drop_na` to remove any rows of the data frame with missing values in them. How many rows do you have left?\n\nSolution\n\n\nThis is as simple as:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges0 %>% drop_na() -> bridges\nbridges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 x 13\n   id    river location erected purpose  length lanes clear_g t_d     material\n   <chr> <chr>    <dbl> <chr>   <chr>    <chr>  <dbl> <chr>   <chr>   <chr>   \n 1 E2    A           25 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 2 E5    A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 3 E7    A           27 CRAFTS  HIGHWAY  SHORT      2 N       THROUGH WOOD    \n 4 E8    A           28 CRAFTS  AQUEDUCT MEDIUM     1 N       THROUGH IRON    \n 5 E9    M            3 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH IRON    \n 6 E11   A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 7 E14   M            6 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 8 E16   A           25 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH IRON    \n 9 E18   A           28 CRAFTS  RR       MEDIUM     2 N       THROUGH IRON    \n10 E19   A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n# i 60 more rows\n# i 3 more variables: span <chr>, rel_l <chr>, type <chr>\n```\n:::\n:::\n\n     \nI have 70 rows left (out of the original 108).\n\n$\\blacksquare$\n\n(d) We are going to assess the dissimilarity between two bridges\nby the number of the categorical variables they *disagree*\non. This is called a \"simple matching coefficient\", and is the\nsame thing we did in the question about clustering fruits based on\ntheir properties. This time, though, we want to count matches in\nthings that are *rows* of our data frame (properties of two\ndifferent bridges), so we will need to use a strategy like the one I\nused in calculating the Bray-Curtis distances.\nFirst, write a function that takes as input two vectors `v`\nand `w` and counts the number of their entries that differ\n(comparing the first with the first, the second with the second,\n\\ldots, the last with the last. I can think of a quick way and a\nslow way, but either way is good.) To test your function, create two\nvectors (using `c`) of the same length, and see whether it\ncorrectly counts the number of corresponding values that are\ndifferent. \n\nSolution\n\n\nThe slow way is to loop through the elements of each vector, using\nsquare brackets to pull out the ones you want, checking them for\ndifferentness, then updating a counter which gets returned at the\nend. If you've done Python, this is exactly the strategy you'd\nuse there:\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_diff <- function(v, w) {\n  n <- length(v)\n  stopifnot(length(v) == length(w)) # I explain this below\n  count <- 0\n  for (i in 1:n) {\n    if (v[i] != w[i]) count <- count + 1\n  }\n  count\n}\n```\n:::\n\n     \n\nThis function makes no sense if `v` and `w` are of\ndifferent lengths, since we're comparing *corresponding* elements\nof them. The `stopifnot` line checks to see whether `v`\nand `w` have the same number of things in them, and stops with\nan informative error if they are of different lengths. (The thing\ninside the `stopifnot` is what has to be *true*.)\n\nDoes it work?\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(1, 1, 0, 0, 0)\nw <- c(1, 2, 0, 2, 0)\ncount_diff(v, w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n \n\nThree of the values are the same and two are different, so this is right.\n\nWhat happens if my two vectors are of different lengths?\n\n::: {.cell}\n\n```{.r .cell-code}\nv1 <- c(1, 1, 0, 0)\nw <- c(1, 2, 0, 2, 0)\ncount_diff(v1, w)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in count_diff(v1, w): length(v) == length(w) is not TRUE\n```\n:::\n:::\n\n \n\nError, as produced by `stopifnot`. See how it's perfectly clear\nwhat went wrong?\n\nR, though, is a \"vectorized\" language: it's possible to work with\nwhole vectors at once, rather than pulling things out of them one at a\ntime. Check out this (which is like what I did with the fruits):\n\n::: {.cell}\n\n```{.r .cell-code}\nv != w\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE FALSE\n```\n:::\n:::\n\n \n\nThe second and fourth values are different, and the others are the\nsame. But we can go one step further:\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(v != w)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n \n\nThe true values count as 1 and the false ones as zero, so the sum is\ncounting up how many values are different, exactly what we want. So\nthe function can be as simple as:\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_diff <- function(v, w) {\n  sum(v != w)\n}\n```\n:::\n\n \n\nI still think it's worth writing a function do this, though, since\n`count_diff` tells you what it does and `sum(v!=w)`\ndoesn't, unless you happen to know.\n\n$\\blacksquare$\n\n(e) Write a function that has as input two row numbers and a data\nframe to take those rows from. The function needs to select all the\ncolumns except for `id` and `location`, select the\nrows required one at a time, and turn them into vectors. (There may\nbe some repetitiousness here. That's OK.)  Then those two vectors\nare passed into the function you wrote in the previous part, and the\ncount of the number of differences is returned. This is like the\ncode in the Bray-Curtis problem. Test your function on rows 3 and 4\nof your bridges data set (with the missings removed). There should\nbe six variables that are different.\n\nSolution\n\n\nThis is just like my function `braycurtis.spec`, except that\ninstead of calling `braycurtis` at the end, I call\n`count_diff`: \n\n::: {.cell}\n\n```{.r .cell-code}\nrow_diff <- function(i, j, d) {\n  d1 <- d %>% select(-id, -location)\n  x <- d1 %>% slice(i) %>% unlist()\n  y <- d1 %>% slice(j) %>% unlist()\n  count_diff(x, y)\n}\nrow_diff(3, 4, bridges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n \n\nThat's what I said.\n\nExtra: is that right, though? Let's print out those rows and count:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges %>% slice(c(3, 4)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 13\n  id    river location erected purpose length lanes clear_g t_d   material span \n  <chr> <chr>    <dbl> <chr>   <chr>   <chr>  <dbl> <chr>   <chr> <chr>    <chr>\n1 E7    A           27 CRAFTS  HIGHWAY SHORT      2 N       THRO~ WOOD     MEDI~\n2 E8    A           28 CRAFTS  AQUEDU~ MEDIUM     1 N       THRO~ IRON     SHORT\n# i 2 more variables: rel_l <chr>, type <chr>\n```\n:::\n:::\n\n \n\nOut of the ones we're counting, I see differences in purpose, length,\nlanes, material, span and type. Six.\n\nI actually think the `unlist` is not needed:\n\n::: {.cell}\n\n```{.r .cell-code}\nrow_diff2 <- function(i, j, d) {\n  d1 <- d %>% select(-id, -location)\n  x <- d1 %>% slice(i)\n  y <- d1 %>% slice(j)\n  count_diff(x, y)\n}\nrow_diff2(3, 4, bridges)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6\n```\n:::\n:::\n\n \n\nHere, `x` and `y` are one-row data frames, but R (via\n`count_diff`) is sufficiently flexible to be able to cope with\nthese rather than vectors (it checks \"corresponding elements\" of\n`x` and `y` for differentness). To my mind, though,\nhaving the `unlist` in is clearer, since it makes it\nunambiguous that `x` and `y` are vectors, and we know\nthat `count_diff` works for vectors since that's what we\ntested it with.\n\n$\\blacksquare$\n\n(f) Create a matrix or data frame of pairwise dissimilarities\nbetween each pair of bridges (using only the ones with no missing\nvalues). Use loops, or `crossing` and `rowwise`, as\nyou prefer. Display the first six rows of\nyour matrix (using `head`) or the first few rows of your data\nframe. (The whole thing is big, so don't display it all.)\n\nSolution\n\n\nFirst thing, either way, is to find out how many bridges we have left:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 x 13\n   id    river location erected purpose  length lanes clear_g t_d     material\n   <chr> <chr>    <dbl> <chr>   <chr>    <chr>  <dbl> <chr>   <chr>   <chr>   \n 1 E2    A           25 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 2 E5    A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 3 E7    A           27 CRAFTS  HIGHWAY  SHORT      2 N       THROUGH WOOD    \n 4 E8    A           28 CRAFTS  AQUEDUCT MEDIUM     1 N       THROUGH IRON    \n 5 E9    M            3 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH IRON    \n 6 E11   A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 7 E14   M            6 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n 8 E16   A           25 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH IRON    \n 9 E18   A           28 CRAFTS  RR       MEDIUM     2 N       THROUGH IRON    \n10 E19   A           29 CRAFTS  HIGHWAY  MEDIUM     2 N       THROUGH WOOD    \n# i 60 more rows\n# i 3 more variables: span <chr>, rel_l <chr>, type <chr>\n```\n:::\n:::\n\n     \n\n70. So the loops (and the `crossing`) will go up to 70. Loops first:\n\n::: {.cell hash='cluster_cache/pdf/pittsburgh-14_67c7f4e73b128a6d10328293c4ca74a1'}\n\n```{.r .cell-code}\nm <- matrix(-1, 70, 70)\nfor (i in 1:70) {\n  for (j in 1:70) {\n    m[i, j] <- row_diff(i, j, bridges)\n  }\n}\n```\n:::\n\n \n\nEven just the top six rows (of all 70 columns) takes up a lot of\nspace. The grader would only check that it looks about right:\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]\n[1,]    0    0    2    4    3    1    2    4    3     1     2     3     7     6\n[2,]    0    0    2    4    3    1    2    4    3     1     2     3     7     6\n[3,]    2    2    0    6    5    1    2    4    5     1     2     5     7     6\n[4,]    4    4    6    0    3    5    6    4    3     5     6     6     8     8\n[5,]    3    3    5    3    0    4    3    3    3     4     5     6     6     5\n[6,]    1    1    1    5    4    0    1    3    4     0     1     4     6     5\n     [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]\n[1,]     7     9     6     7     3     8     7     9     8     6     7     6\n[2,]     7     9     6     7     3     8     7     9     8     6     7     6\n[3,]     7     9     6     7     5     8     8     9     7     6     6     6\n[4,]     8    10     8     8     3    10     9    10     9     8     9     8\n[5,]     6     9     7     6     6     7     6    10     7     7     8     7\n[6,]     6     9     5     6     4     8     7     9     7     5     6     5\n     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]\n[1,]     7     7     8     8     9     6     8     7     9     7     8     8\n[2,]     7     7     8     8     9     6     8     7     9     7     8     8\n[3,]     7     6     8     8     7     7     9     8     9     8     8     7\n[4,]     8     8     9     9     9     8     9     9    10     8     9     9\n[5,]     6     8     7     7    10     7     8     7     9     8     9     9\n[6,]     6     6     7     7     8     6     8     7     9     7     8     7\n     [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]\n[1,]     8     7     8     8     7     9     8     9     9     8     7     8\n[2,]     8     7     8     8     7     9     8     9     9     8     7     8\n[3,]     6     6     6     6     8     8     9     8     8     6     6     9\n[4,]     9     8     8     8     9    10     9    10    11     8     9     9\n[5,]     9     8     8     8     7     8     7    10     8     8     6     8\n[6,]     7     6     7     7     7     8     8     8     8     7     6     8\n     [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62]\n[1,]     7     8     8     8     8     8     6     8     7     9    10     8\n[2,]     7     8     8     8     8     8     6     8     7     9    10     8\n[3,]     8     9     9     8     8     6     6     8     7     7    10     9\n[4,]     8     8     9     9     9     9     8    10     9    10    11     9\n[5,]     7     6     7     9     9     9     7     8     6     8     9     7\n[6,]     7     8     8     7     7     7     5     8     6     8    10     8\n     [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70]\n[1,]     8     7     8     9    10     8     9     9\n[2,]     8     7     8     9    10     8     9     9\n[3,]     8     8     9     7    10     6     9     8\n[4,]     9     9     9    10    11     9    10    10\n[5,]     9     7     7    10     9     9     9     8\n[6,]     8     7     8     8    10     7     9     9\n```\n:::\n:::\n\n \n\nA cursory glance at this shows that the bridges in the small-numbered\nrows of the data frame are similar to each other and different from\nthe others. This suggests that these small-numbered bridges will end\nup in the same cluster (later).\n\nThe `tidyverse` way is really similar in conception. First use\n`crossing`^[Rather than `datagrid`, which is specifically for predictions for combinations of things from a model.] to create all combinations of `i` and `j`:\n\n::: {.cell}\n\n```{.r .cell-code}\nmm <- crossing(i = 1:70, j = 1:70)\n```\n:::\n\n \n\nand then use `rowwise`:\n\n::: {.cell hash='cluster_cache/pdf/pittsburgh-17_10042aed0ca65b57eead36366e96b307'}\n\n```{.r .cell-code}\nmm %>% \n  rowwise() %>% \n  mutate(diff = row_diff(i, j, bridges)) -> mm\nmm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4,900 x 3\n# Rowwise: \n       i     j  diff\n   <int> <int> <int>\n 1     1     1     0\n 2     1     2     0\n 3     1     3     2\n 4     1     4     4\n 5     1     5     3\n 6     1     6     1\n 7     1     7     2\n 8     1     8     4\n 9     1     9     3\n10     1    10     1\n# i 4,890 more rows\n```\n:::\n:::\n\nIf you forget the `rowwise`, the answers (in `diff`) will all be the same, which should make you suspicious.\n\nThis is long format, though, so we need to `pivot_wider` the\n`j` column to get a square array of dissimilarities:\n\n::: {.cell}\n\n```{.r .cell-code}\nmm %>% pivot_wider(names_from=j, values_from=diff) -> mm\nmm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 x 71\n       i   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`  `11`  `12`\n   <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int> <int>\n 1     1     0     0     2     4     3     1     2     4     3     1     2     3\n 2     2     0     0     2     4     3     1     2     4     3     1     2     3\n 3     3     2     2     0     6     5     1     2     4     5     1     2     5\n 4     4     4     4     6     0     3     5     6     4     3     5     6     6\n 5     5     3     3     5     3     0     4     3     3     3     4     5     6\n 6     6     1     1     1     5     4     0     1     3     4     0     1     4\n 7     7     2     2     2     6     3     1     0     4     5     1     2     5\n 8     8     4     4     4     4     3     3     4     0     4     3     4     7\n 9     9     3     3     5     3     3     4     5     4     0     4     5     6\n10    10     1     1     1     5     4     0     1     3     4     0     1     4\n# i 60 more rows\n# i 58 more variables: `13` <int>, `14` <int>, `15` <int>, `16` <int>,\n#   `17` <int>, `18` <int>, `19` <int>, `20` <int>, `21` <int>, `22` <int>,\n#   `23` <int>, `24` <int>, `25` <int>, `26` <int>, `27` <int>, `28` <int>,\n#   `29` <int>, `30` <int>, `31` <int>, `32` <int>, `33` <int>, `34` <int>,\n#   `35` <int>, `36` <int>, `37` <int>, `38` <int>, `39` <int>, `40` <int>,\n#   `41` <int>, `42` <int>, `43` <int>, `44` <int>, `45` <int>, `46` <int>, ...\n```\n:::\n:::\n\n \n\nThis shows what we found before, that bridges 3 and 4 differ on 6\nvariables. \n\n$\\blacksquare$\n\n(g) Turn your matrix or data frame into a `dist`\nobject. (If you couldn't create a matrix or data frame of\ndissimilarities, read them in from\n[link](https://raw.githubusercontent.com/nxskok/datafiles/master/mm.csv).) Do not\ndisplay your distance object.\n\nSolution\n\n\nThe only tricky thing is that the data frame that I called\n`mm` has an extra column called `i` that needs to be\nremoved first. This also applies if you need to read it in from\nthe file. Thus:\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- as.dist(m)\n```\n:::\n\n     \n\nor \n\n::: {.cell}\n\n```{.r .cell-code}\nmm %>% select(-i) %>% as.dist() -> d2\n```\n:::\n\n \n\nor, if you got stuck,\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/mm.csv\"\nmmm <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 70 Columns: 71\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\ndbl (71): i, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, ...\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\nmmm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 70 x 71\n       i   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`  `11`  `12`\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1     1     0     0     2     4     3     1     2     4     3     1     2     3\n 2     2     0     0     2     4     3     1     2     4     3     1     2     3\n 3     3     2     2     0     6     5     1     2     4     5     1     2     5\n 4     4     4     4     6     0     3     5     6     4     3     5     6     6\n 5     5     3     3     5     3     0     4     3     3     3     4     5     6\n 6     6     1     1     1     5     4     0     1     3     4     0     1     4\n 7     7     2     2     2     6     3     1     0     4     5     1     2     5\n 8     8     4     4     4     4     3     3     4     0     4     3     4     7\n 9     9     3     3     5     3     3     4     5     4     0     4     5     6\n10    10     1     1     1     5     4     0     1     3     4     0     1     4\n# i 60 more rows\n# i 58 more variables: `13` <dbl>, `14` <dbl>, `15` <dbl>, `16` <dbl>,\n#   `17` <dbl>, `18` <dbl>, `19` <dbl>, `20` <dbl>, `21` <dbl>, `22` <dbl>,\n#   `23` <dbl>, `24` <dbl>, `25` <dbl>, `26` <dbl>, `27` <dbl>, `28` <dbl>,\n#   `29` <dbl>, `30` <dbl>, `31` <dbl>, `32` <dbl>, `33` <dbl>, `34` <dbl>,\n#   `35` <dbl>, `36` <dbl>, `37` <dbl>, `38` <dbl>, `39` <dbl>, `40` <dbl>,\n#   `41` <dbl>, `42` <dbl>, `43` <dbl>, `44` <dbl>, `45` <dbl>, `46` <dbl>, ...\n```\n:::\n\n```{.r .cell-code}\nmmm %>% select(-i) %>% as.dist() -> d3\nd3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n2   0                                                                        \n3   2  2                                                                     \n4   4  4  6                                                                  \n5   3  3  5  3                                                               \n6   1  1  1  5  4                                                            \n7   2  2  2  6  3  1                                                         \n8   4  4  4  4  3  3  4                                                      \n9   3  3  5  3  3  4  5  4                                                   \n10  1  1  1  5  4  0  1  3  4                                                \n11  2  2  2  6  5  1  2  4  5  1                                             \n12  3  3  5  6  6  4  5  7  6  4  3                                          \n13  7  7  7  8  6  6  5  7  5  6  5  6                                       \n14  6  6  6  8  5  5  4  6  7  5  4  5  2                                    \n15  7  7  7  8  6  6  5  7  5  6  5  6  0  2                                 \n16  9  9  9 10  9  9  9  9  7  9  8  8  4  6  4                              \n17  6  6  6  8  7  5  6  5  6  5  5  6  4  4  4  5                           \n18  7  7  7  8  6  6  5  7  5  6  6  7  1  3  1  5  3                        \n19  3  3  5  3  6  4  5  7  5  4  4  4  8  8  8 10  7  7                     \n20  8  8  8 10  7  8  7  8  8  8  8  8  5  5  5  3  3  4  9                  \n21  7  7  8  9  6  7  6  7  8  7  7  7  5  3  5  5  3  4  8  2               \n22  9  9  9 10 10  9 10  9  7  9  9  9  6  8  6  3  4  5  9  3  5            \n23  8  8  7  9  7  7  6  8  6  7  7  8  2  4  2  4  4  1  8  3  5  4         \n24  6  6  6  8  7  5  6  5  6  5  5  6  4  4  4  5  0  3  7  3  3  4  4      \n25  7  7  6  9  8  6  7  6  7  6  6  7  5  5  5  4  1  4  8  2  4  3  3  1   \n26  6  6  6  8  7  5  6  5  7  5  5  6  5  4  5  6  1  4  7  4  3  5  5  1  2\n27  7  7  7  8  6  6  5  7  5  6  6  7  1  3  1  5  3  0  7  4  4  5  1  3  4\n28  7  7  6  8  8  6  7  7  5  6  6  7  3  5  3  4  3  2  7  4  6  3  1  3  2\n29  8  8  8  9  7  7  6  7  6  7  7  8  2  4  2  4  2  1  8  3  3  4  2  2  3\n30  8  8  8  9  7  7  6  6  6  7  7  8  2  4  2  5  3  1  8  4  4  5  2  3  4\n31  9  9  7  9 10  8  9  7  7  8  8  7  5  7  5  6  4  4  8  6  7  5  4  4  4\n32  6  6  7  8  7  6  7  6  6  6  6  6  5  5  5  4  1  4  7  2  2  3  5  1  2\n33  8  8  9  9  8  8  8  8  7  8  8  8  5  6  5  3  4  4  8  4  3  4  5  4  5\n34  7  7  8  9  7  7  7  7  8  7  7  7  6  5  6  4  3  5  8  3  2  5  6  3  4\n35  9  9  9 10  9  9  9  9  7  9  9  9  5  7  5  1  4  4  9  2  4  2  3  4  3\n36  7  7  8  8  8  7  8  7  7  7  7  5  6  6  6  5  2  5  7  3  3  4  6  2  3\n37  8  8  8  9  9  8  9  8  7  8  8 10  8  9  8  5  6  7  8  5  6  2  6  6  5\n38  8  8  7  9  9  7  8  7  6  7  7  8  4  6  4  3  2  3  8  3  5  2  2  2  1\n39  8  8  6  9  9  7  8  7  9  7  7  6  7  5  7  7  3  6  8  5  4  6  6  3  3\n40  7  7  6  8  8  6  7  7  8  6  6  5  6  4  6  7  4  5  7  5  5  6  4  4  3\n41  8  8  6  8  8  7  8  5  9  7  7  6  7  6  7  8  4  6  8  6  6  7  6  4  4\n42  8  8  6  8  8  7  8  5  9  7  7  6  7  6  7  8  4  6  8  6  6  7  6  4  4\n43  7  7  8  9  7  7  7  6  8  7  7  7  6  5  6  5  4  5  8  4  3  6  6  4  5\n44  9  9  8 10  8  8  7  7 10  8  8  9  8  7  8  9  7  7  9  6  7  7  6  7  6\n45  8  8  9  9  7  8  7  8  9  8  8  6  6  5  6  6  4  5  8  3  2  6  6  4  5\n46  9  9  8 10 10  8  9  8 10  8  8  7  8  6  8  7  4  7  9  5  5  4  6  4  3\n47  9  9  8 11  8  8  7  7 10  8  8  9  6  5  6  7  5  5 10  4  5  5  4  5  4\n48  8  8  6  8  8  7  8  5  9  7  7  6  7  6  7  8  4  6  8  6  6  7  6  4  4\n49  7  7  6  9  6  6  5  7  7  6  6  7  3  3  3  5  3  2  8  2  4  5  1  3  2\n50  8  8  9  9  8  8  8  8  9  8  8  6  7  5  7  5  4  6  8  4  2  6  7  4  5\n51  7  7  8  8  7  7  7  7  8  7  7  7  8  6  8  6  5  7  7  5  3  7  8  5  6\n52  8  8  9  8  6  8  7  7  9  8  8  6  6  5  6  6  4  5  8  3  2  6  6  4  5\n53  8  8  9  9  7  8  7  7  9  8  8  8  8  7  8  9  7  7  8  6  5  7  8  7  8\n54  8  8  8  9  9  7  8  7  9  7  7  6  7  6  7  8  3  6  8  6  5  5  7  3  4\n55  8  8  8  9  9  7  8  6  9  7  7  6  7  6  7  9  5  7  9  8  7  7  8  5  6\n56  8  8  6  9  9  7  8  6  6  7  7  8  4  6  4  5  4  4  9  6  7  5  4  4  4\n57  6  6  6  8  7  5  6  4  7  5  5  8  7  6  7  9  5  7  8  8  7  7  8  5  6\n58  8  8  8 10  8  8  8  8  9  8  8  8  7  6  7  3  5  7 10  3  4  5  6  5  4\n59  7  7  7  9  6  6  5  5  7  6  6  7  3  3  3  6  3  3  9  4  4  7  4  3  4\n60  9  9  7 10  8  8  7  8 10  8  8  7  6  5  6  7  5  6 10  5  5  8  6  5  5\n61 10 10 10 11  9 10  9 10 11 10 10  8  8  7  8  6  7  8 11  4  5  5  7  7  6\n62  8  8  9  9  7  8  7  8  9  8  8  6  6  5  6  6  5  6  9  4  3  7  7  5  6\n63  8  8  8  9  9  8  9  8  9  8  8  8 10  9 10  7  7 10  9  6  7  5  9  7  6\n64  7  7  8  9  7  7  7  7  8  7  7  7  6  5  6  4  4  6  9  4  3  6  7  4  5\n65  8  8  9  9  7  8  7  8  9  8  8  7  6  4  6  6  5  6  9  4  2  7  7  5  6\n66  9  9  7 10 10  8  9  7 10  8  8  7  8  7  8  9  6  8 10  8  8  7  8  6  6\n67 10 10 10 11  9 10  9 10 11 10 10  8  8  7  8  6  7  8 11  4  5  5  7  7  6\n68  8  8  6  9  9  7  8  7  9  7  7  7  7  5  7  7  4  7  9  6  5  7  7  4  4\n69  9  9  9 10  9  9  9  9 10  9  9  8  8  6  8  4  6  8 10  4  4  6  7  6  5\n70  9  9  8 10  8  9  8  9 10  9  9  8  7  5  7  6  6  7 10  4  3  7  7  6  6\n   26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\n2                                                                            \n3                                                                            \n4                                                                            \n5                                                                            \n6                                                                            \n7                                                                            \n8                                                                            \n9                                                                            \n10                                                                           \n11                                                                           \n12                                                                           \n13                                                                           \n14                                                                           \n15                                                                           \n16                                                                           \n17                                                                           \n18                                                                           \n19                                                                           \n20                                                                           \n21                                                                           \n22                                                                           \n23                                                                           \n24                                                                           \n25                                                                           \n26                                                                           \n27  4                                                                        \n28  4  2                                                                     \n29  3  1  3                                                                  \n30  4  1  3  1                                                               \n31  5  4  3  4  3                                                            \n32  2  4  4  3  4  5                                                         \n33  3  4  5  3  4  6  3                                                      \n34  2  5  6  4  5  7  2  1                                                   \n35  5  4  3  3  4  5  3  2  3                                                \n36  3  5  5  4  5  4  1  4  3  4                                             \n37  6  7  5  6  7  7  5  5  6  4  6                                          \n38  3  3  1  2  3  3  3  4  5  2  4  4                                       \n39  3  6  5  5  6  3  4  6  5  6  3  7  4                                    \n40  4  5  3  6  6  4  5  7  6  6  4  7  4  2                                 \n41  4  6  5  6  5  2  5  7  6  7  4  8  5  2  3                              \n42  4  6  5  6  5  2  5  7  6  7  4  8  5  2  3  0                           \n43  3  5  6  5  4  6  3  2  1  4  4  7  6  6  6  5  5                        \n44  6  7  7  7  6  6  8  8  7  8  7  6  7  6  5  5  5  6                     \n45  3  5  7  4  5  6  3  3  2  5  2  7  6  4  5  5  5  3  5                  \n46  4  7  5  6  7  5  5  7  6  6  4  5  4  2  2  4  4  7  4  5               \n47  4  5  5  5  4  6  6  6  5  6  7  6  5  6  5  5  5  4  2  5  4            \n48  4  6  5  6  5  2  5  7  6  7  4  8  5  2  3  0  0  5  5  5  4  5         \n49  4  2  2  3  3  5  4  6  5  4  5  7  3  5  3  5  5  5  5  5  5  3  5      \n50  4  6  7  5  6  6  3  3  2  4  2  7  6  3  4  5  5  3  7  2  4  7  5  6   \n51  5  7  8  6  7  7  4  4  3  5  3  6  7  4  5  6  6  4  6  3  5  8  6  7  1\n52  4  5  7  4  5  6  3  4  3  5  2  7  6  4  5  4  4  4  6  1  5  6  4  5  2\n53  7  7  9  7  6  7  6  7  6  8  5  5  9  7  7  6  6  5  3  4  6  5  6  7  5\n54  2  6  6  5  6  5  4  5  4  7  3  6  5  3  4  4  4  5  4  3  2  4  4  6  4\n55  5  7  7  7  6  5  6  8  7  9  5  7  7  5  5  4  4  6  5  6  4  5  4  7  6\n56  5  4  3  4  3  2  5  6  7  5  6  7  3  5  6  4  4  6  8  8  7  6  4  5  8\n57  5  7  7  7  6  7  6  8  7  9  7  5  7  7  7  6  6  6  5  8  6  5  6  7  8\n58  4  7  6  6  7  8  4  3  2  3  5  6  5  6  6  7  7  3  7  4  6  5  7  5  4\n59  4  3  5  3  2  5  4  6  5  6  5  9  5  6  6  5  5  4  6  5  7  4  5  3  6\n60  5  6  7  5  6  5  6  7  6  7  5  8  6  3  5  4  4  7  6  4  5  6  4  5  5\n61  7  8  8  7  8  8  6  7  6  6  5  5  7  6  6  7  7  7  5  4  4  5  7  6  5\n62  4  6  8  5  6  7  4  4  3  6  3  8  7  5  6  6  6  4  6  1  6  6  6  6  3\n63  7 10  8  9 10  8  6  8  7  7  5  3  7  6  6  7  7  8  5  6  4  7  7  8  6\n64  4  6  7  5  6  8  3  3  2  4  4  6  6  6  7  7  7  3  9  4  7  7  7  6  3\n65  5  6  8  5  6  8  4  5  4  6  4  8  7  5  6  7  7  5  8  3  6  7  7  6  3\n66  6  8  7  8  7  4  7  9  8  9  6  7  7  4  5  3  3  7  5  7  4  5  3  7  7\n67  7  8  8  7  8  8  6  7  6  6  5  5  7  6  6  7  7  7  5  4  4  5  7  6  5\n68  4  7  6  6  7  5  5  7  6  7  5  8  5  2  4  4  4  7  8  6  4  7  4  6  5\n69  6  8  7  7  8  8  5  5  4  4  5  7  6  5  5  7  7  5  8  5  5  7  7  6  3\n70  6  7  8  6  7  7  5  6  5  6  5  8  7  4  6  6  6  6  8  4  6  7  6  6  4\n   51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69\n2                                                          \n3                                                          \n4                                                          \n5                                                          \n6                                                          \n7                                                          \n8                                                          \n9                                                          \n10                                                         \n11                                                         \n12                                                         \n13                                                         \n14                                                         \n15                                                         \n16                                                         \n17                                                         \n18                                                         \n19                                                         \n20                                                         \n21                                                         \n22                                                         \n23                                                         \n24                                                         \n25                                                         \n26                                                         \n27                                                         \n28                                                         \n29                                                         \n30                                                         \n31                                                         \n32                                                         \n33                                                         \n34                                                         \n35                                                         \n36                                                         \n37                                                         \n38                                                         \n39                                                         \n40                                                         \n41                                                         \n42                                                         \n43                                                         \n44                                                         \n45                                                         \n46                                                         \n47                                                         \n48                                                         \n49                                                         \n50                                                         \n51                                                         \n52  3                                                      \n53  4  4                                                   \n54  5  4  5                                                \n55  7  6  4  3                                             \n56  9  8  9  7  5                                          \n57  7  8  4  5  2  5                                       \n58  5  5  8  6  7  6  7                                    \n59  7  5  6  6  4  3  4  5                                 \n60  6  4  6  5  4  5  6  5  4                              \n61  6  4  4  5  4  8  6  4  6  3                           \n62  4  2  5  4  5  7  7  3  4  3  3                        \n63  5  6  4  5  4  8  4  5  8  5  2  5                     \n64  4  4  6  6  5  6  5  2  4  4  4  3  5                  \n65  4  3  6  6  6  7  7  4  4  4  4  2  6  3               \n66  8  7  5  4  1  4  3  7  5  3  4  6  4  6  7            \n67  6  4  4  5  4  8  6  4  6  3  0  3  2  4  4  4         \n68  6  6  9  5  5  4  6  5  5  3  6  5  6  5  3  4  6      \n69  4  5  8  7  7  7  8  2  6  5  4  4  5  3  2  7  4  3   \n70  5  4  7  7  7  6  8  4  5  3  4  3  6  4  1  6  4  2  2\n```\n:::\n:::\n\n \n$\\blacksquare$\n\n(h) Run a cluster analysis using Ward's method, and display a\ndendrogram. The labels for the bridges (rows of the data frame) may\ncome out too big; experiment with a `cex` less than 1 on the\nplot so that you can see them.\n\nSolution\n\n\nHome stretch now. I found that `cex=0.3` was good for me, though I had to enlarge the graph to see the bridge numbers:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges.1 <- hclust(d1, method = \"ward.D\")\nplot(bridges.1, cex = 0.3)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/pittsburgh-22-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n\n`cex` stands for \"character expansion\". This is one of the\nmyriad of things you could adjust on the old base graphics (of which\nthis is an example). If you wanted to make text *bigger*, you'd\nset `cex` to a value bigger than 1.\n\n$\\blacksquare$\n\n(i) How many clusters do you think is reasonable for these\ndata? Draw them on your plot.\n\nSolution\n\n\nI think you could go with any number from about 3 to something\nlike 15, but my choice is 5. What you want is for the bridges\nwithin a cluster to be similar and bridges in different clusters\nto be different, however you judge that.\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(bridges.1, cex = 0.3)\nrect.hclust(bridges.1, 5)\n```\n\n::: {.cell-output-display}\n![](cluster_files/figure-pdf/pittsburgh-23-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \n\nWhatever number of clusters you go with, draw a corresponding number\nof red rectangles.\n\nNote that the low-numbered bridges are all in my first cluster, as I\nsuspected they would be.\n\n$\\blacksquare$\n\n(j) Pick three bridges in the same one of your clusters (it\ndoesn't matter which three bridges or which cluster). Display the\ndata for these bridges. Does it make sense that these three bridges\nended up in the same cluster? Explain briefly.\n\nSolution\n\n\nWhat I want you to do is to display the data for your chosen three\nbridges and make the case that they are \"similar\". I'm picking\n41, 42 and 48 from my third cluster. On yours, scroll right to see the other variables.\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges %>% slice(c(41, 42, 48))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 13\n  id    river location erected purpose length lanes clear_g t_d   material span \n  <chr> <chr>    <dbl> <chr>   <chr>   <chr>  <dbl> <chr>   <chr> <chr>    <chr>\n1 E70   A           27 MATURE  HIGHWAY SHORT      4 G       THRO~ STEEL    MEDI~\n2 E69   A           26 MATURE  HIGHWAY SHORT      4 G       THRO~ STEEL    MEDI~\n3 E71   A           25 MATURE  HIGHWAY SHORT      4 G       THRO~ STEEL    MEDI~\n# i 2 more variables: rel_l <chr>, type <chr>\n```\n:::\n:::\n\n     \n\nThese bridges are identical on everything except location (which we\nweren't considering anyway). So it makes perfect sense that they would\nbe in the same cluster.\n\nYou might not have been so lucky, for example, 10, 12 and 19, which\ngot joined together further up:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges %>% slice(c(10, 12, 19))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 13\n  id    river location erected purpose length lanes clear_g t_d   material span \n  <chr> <chr>    <dbl> <chr>   <chr>   <chr>  <dbl> <chr>   <chr> <chr>    <chr>\n1 E19   A           29 CRAFTS  HIGHWAY MEDIUM     2 N       THRO~ WOOD     MEDI~\n2 E22   A           24 EMERGI~ HIGHWAY MEDIUM     4 G       THRO~ WOOD     SHORT\n3 E4    A           27 MATURE  AQUEDU~ MEDIUM     1 N       THRO~ WOOD     SHORT\n# i 2 more variables: rel_l <chr>, type <chr>\n```\n:::\n:::\n\n     \n\nThese differ on 3 or 4 variables and are the same on all the others,\nso you can certainly say that they are more alike than different.\n\nExtra: to get a feel for how different they might be, let's compare\nthree bridges in different clusters:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges %>% slice(c(8, 24, 52))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 13\n  id    river location erected purpose length lanes clear_g t_d   material span \n  <chr> <chr>    <dbl> <chr>   <chr>   <chr>  <dbl> <chr>   <chr> <chr>    <chr>\n1 E16   A           25 CRAFTS  HIGHWAY MEDIUM     2 N       THRO~ IRON     MEDI~\n2 E58   A           33 MATURE  HIGHWAY MEDIUM     2 G       THRO~ STEEL    MEDI~\n3 E76   M            6 MATURE  HIGHWAY MEDIUM     4 G       THRO~ STEEL    LONG \n# i 2 more variables: rel_l <chr>, type <chr>\n```\n:::\n:::\n\n \n\nThese are not as different as I was expecting, but they are indeed\ndifferent on more of the variables.\n\nIt would be interesting to plot these bridges on a map of Pittsburgh,\ncolour-coded by which cluster they are in. This might give us some\ninsight about how bridges are alike or different. \n\nI also remark that the discriminant analysis idea, using the clusters\nas known groups, would not work here because we don't have any\nquantitative variables to use for the discriminant analysis. \n\nThe most interesting way I can think of is to cross-classify the\nbridges by cluster and values of the other variables. These would be\ncomplicated multi-way tables, though, which makes me wonder whether a\n\"classification tree\" like `rpart` would be worth thinking\nabout. \n\nI am curious enough to have a crack at this. First we need a data set\nwith the clusters in it. I'm going with my 5 clusters:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges.rpart <- bridges %>% mutate(cluster = cutree(bridges.1, 5))\n```\n:::\n\n \n\nand then\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rpart)\nbridges.tree <- rpart(factor(cluster) ~ river + erected + purpose + length + lanes + clear_g +\n  t_d + material + span + rel_l + type, data = bridges.rpart, method = \"class\")\nprint(bridges.tree)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nn= 70 \n\nnode), split, n, loss, yval, (yprob)\n      * denotes terminal node\n\n 1) root 70 47 3 (0.19 0.16 0.33 0.2 0.13)  \n   2) span=MEDIUM,SHORT 45 31 4 (0.29 0.24 0.044 0.31 0.11)  \n     4) material=IRON,WOOD 13  0 1 (1 0 0 0 0) *\n     5) material=STEEL 32 18 4 (0 0.34 0.062 0.44 0.16)  \n      10) river=M 13  3 2 (0 0.77 0.077 0 0.15) *\n      11) river=A 19  5 4 (0 0.053 0.053 0.74 0.16) *\n   3) span=LONG 25  4 3 (0 0 0.84 0 0.16)  \n     6) type=ARCH,CANTILEV,SIMPLE-T 18  0 3 (0 0 1 0 0) *\n     7) type=CONT-T,SUSPEN 7  3 5 (0 0 0.43 0 0.57) *\n```\n:::\n:::\n\n \n\nThis takes some making sense of, so let's grab a couple of bridges to\npredict the cluster of:\n\n::: {.cell}\n\n```{.r .cell-code}\nbridges.rpart %>% slice(c(20, 29)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 14\n  id    river location erected purpose length lanes clear_g t_d   material span \n  <chr> <chr>    <dbl> <chr>   <chr>   <chr>  <dbl> <chr>   <chr> <chr>    <chr>\n1 E42   M            9 MATURE  HIGHWAY LONG       2 G       THRO~ STEEL    LONG \n2 E51   M            6 MATURE  RR      MEDIUM     2 G       THRO~ STEEL    MEDI~\n# i 3 more variables: rel_l <chr>, type <chr>, cluster <int>\n```\n:::\n:::\n\n \n\nLet's start with bridge 20 (with ID E42). The line in the printed\noutput marked 1 and \"root\" says that there are 70 bridges\naltogether, and the best guess (if you know nothing) is to guess\ncluster 3, which would guess 47 of the bridges wrong. The five numbers\nin the brackets are the proportions of bridges in each cluster at this\npoint. But we *do* know more about bridge E42. We go to number 2,\nwhich says to look at the `span`. For this bridge it is\n`LONG`, so we go down to number 3. Under 3 are 6 and 7, which\nsay to look at `type`. Bridge E42 is of type `SIMPLE-T`,\nso we go to 6. There is nothing under this (lower down in the tree),\nand the line ends with a `*`, so we are ready to guess the\ncluster. There are 18 bridges with this `span` and one of these\n`type`s, and they are *all* in cluster 3, no\nerrors. Cluster 3 contains long-span bridges of one of those types.\n\nBridge 29, with ID E51, now. The first thing to look at is\n`span` again; this one is `medium`, so we are at\n2. Under 2 is 4 and 5; we are invited to look at `material`,\nwhich is `STEEL`, number 5. We have another thing to look at,\n10 and 11, which is `river`; in this case, `river` is\n`M`, number 10. We are now at the end, guessing cluster 2\n(which is also correct); there are 13 bridges of this `span`,\n`material` and `river` and only 3 of them were in some\ncluster other than 2.\n\nBy looking at the tree output, we can describe what makes a bridge be\npredicted to land up in each cluster:\n\n\n\n* Span is medium or short, material is iron or wood. (This\nsuggests old bridges.)\n\n* Span is medium or short, material is steel, river is M.\n\n* Span is long, type is arch, cantilever or simple-truss\n\n* Span is medium or short, material is steel, river is A.\n\n* Span is long, type is continuous-truss or suspension.\n\n\nThis story is telling us that the clusters are determined by only a\nfew of our variables. `span` seems to be the most important,\nthen either type (if the span is long) or material and maybe river\n(otherwise). \n\nThis is an example of a \"classification tree\" which is a nice\neasy-to-follow version of logistic regression.\n\n$\\blacksquare$\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}