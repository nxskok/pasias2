{
  "hash": "7c503192e0c2e2431b4c81f98c1c06ed",
  "result": {
    "engine": "knitr",
    "markdown": "# Bayesian Statistics with Stan\n\nPackages for this chapter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(cmdstanr)\nlibrary(posterior)\nlibrary(bayesplot)\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n##  Estimating proportion in favour from a survey\n\n\n You are probably familiar with the kind of surveys where you are given a statement, like \"I am the kind of person that finishes a task they start\", \nand you have to express your agreement or disagreement with it. \nUsually, you are given a five-point or seven-point scale on which you express your level of agreement (from \"strongly agree\" \nthrough \"neither agree nor disagree\" to \n\"strongly disagree\", for example). Here, we will simplify things a little and only allow respondents to agree or disagree. \nSo the kind of data you would have is a number of people that took part, and the number of these that said \"agree\".\n\nCommon assumptions that are made in this kind of analysis are:\n(i) the responses are independent of each other, and (ii) each respondent has the same unknown probability of agreeing. \nYou might quibble about (ii), but the assumption we are making here is that we know *nothing* about the respondents apart from whether they agreed or disagreed. \n(In practice, we'd collect all kinds of demographic information about each respondent, and this might give us a clue about how they'll respond, but here we're keeping it simple.)\nUnder our assumptions, the number of respondents that agree has a binomial distribution with $n$ being our sample size, and $p$ being the probability we are trying to estimate. Let's estimate $p$ using Stan: that is to say, let's obtain the posterior distribution of $p$.\n\n\n\n(a) In R Studio, open a new Stan file (with File, New File, Stan File). \nYou'll see a template file of Stan code. \nEdit the `model` section to reflect that you have observed a number of successes `x` that we are modelling to have a binomial distribution with number of trials `n` and success probability `p`.\n\n\n(b) In the line of Stan code you wrote, there should be three variables.\nWhich of these are parameters and which are data? Explain briefly.\n\n\n(c) I hope you found that there is only one parameter, `p`, in this problem. We know that $0 \\le p \\le 1$, and we need a prior distribution for it. A common choice is a beta distribution. \nLook at the Stan manual, [link](https://mc-stan.org/docs/2_18/functions-reference/beta-distribution.html). \nThe density function is given in 19.1.1. \nIt has two parameters $\\alpha>0$ and $\\beta>0$. $B(\\alpha, \\beta)$ given there is a constant. \nAdd to your `model` section to express that `p` has a prior distribution with parameters `alpha` and `beta`. \n(`alpha` and `beta` will be input data when we run this code.)\n\n\n(d) Above your `model` section, complete a `parameters` section that says what kind of variable `p` is.\nIf `p` has upper or lower limits, put these in as well.\nYou can edit the `parameters` section that is in the template.\n\n\n(e) Everything else is `data`. Complete a `data` section (edit the one in the template) to say what type of thing everything else is, including limits if it has any. \nDon't forget the parameters in the prior distribution!\n\n\n(f) Save your code, if you haven't already. I used the filename `binomial.stan`. \nIn your Stan code window, at the top right, you'll see a button marked Check. This checks whether your code is syntactically correct. Click it.\n\n\n\n(g) Compile your model. (This may take a minute or so, depending on how fast your \nR Studio is.) When the spinny thing stops spinning, it's done.\n\n\n\n(h) In most surveys, the probability to be estimated is fairly close to 0.5. \nA beta prior with $\\alpha=\\beta=2$ expresses the idea that any value of `p` is possible, but values near 0.5 are more likely.\n\nA survey of 277 randomly selected adult female shoppers was taken. 69 of them agreed that when an advertised item is not available at the local supermarket, they request a raincheck.\n\nUsing the above information, set up a data `list` suitable for input to a run of `stan`.\n\n\n\n(i) Sample from the posterior distribution of `p` with these data, and display your results.\n\n\n\n(j) Obtain a 90\\% posterior interval for the probability that a randomly chosen adult female shopper will request a raincheck.\n\n\n\n(k) Obtain a 95\\% (frequentist) confidence interval for `p`, and compare the results. (Hint: `prop.test`.) Comment briefly.\n\n\n\n(l) (optional) This is one of those problems where you can obtain the answer analytically. What is the posterior distribution of $p$, using a prior $beta(\\alpha, \\beta)$ distribution for $p$ and observing $x$ successes out of $n$ trials?\n\n\n\n\n\n\n##  Bayesian regression\n\n\n In this question, we will develop Stan code to run a simple\nlinear regression, and later apply it to some data (and do a bit of\nelicitation of prior distributions along the way).\n\n\n\n(a) Create a `.stan` file that will run a simple linear\nregression predicting a variable `y` from a variable\n`x`, estimating an intercept `a` and a slope\n`b`. Use normal prior distributions for `a` and\n`b`, and allow the means and SDs of the prior distributions\nfor `a` and `b` to be specified (as data, later). The\nregression model says that the response `y` has a normal\ndistribution with mean `a+bx` and SD `sigma` which is\nalso estimated. Give this a prior chi-squared distribution with a\nprior mean that is also input.\n\n\n(b) Check your Stan code for syntactic correctness, and when it is\ncorrect, compile it.\n\n\n(c) We are going to be analyzing some data on vocabulary size (the number of words known) by children of different ages. It is suspected that the relationship between age and vocabulary size is approximately linear.\nYou go consult with an early childhood expert, and they tell you this:\n\n\n* In children of age up to about six, vocabulary almost always\nincreases by between 300 and 700 words per year.\n\n* I can't talk about vocabulary of children of age 0, because children don't start learning to talk until age about 18 months (1.5 years).\n\n* Children of age 1.5 years almost always have a vocabulary\nbetween 0 and 500 words (depending on exactly what age they\nstarted talking.)\n\n* Even if we know a child's age, our prediction of their\nvocabulary size might be off by as much as 200 words.\n\nUse this information to obtain parameters for your prior distributions.\n\n\n(d) Some data were collected on age and vocabulary size of 10\nrandomly selected children, shown here:\n[link](http://ritsokiguess.site/datafiles/vocab.txt). Read\nin and display the data; the values are separated by single spaces.\n\n\n(e) Use this dataset, along with your prior distribution from\nabove, to obtain posterior distributions for intercept, slope and\nerror SD. What is the 95\\% posterior interval for the slope?\n\n\n(f) Plot a histogram of the posterior distribution of the slope. Does its shape surprise you? Explain briefly.\n\n\n\n(g) What can we say about the vocabulary size of a randomly\nselected child of age 5 (a new one, not the one in the original data\nset)? Use an appropriate predictive distribution.\n\n\n\n\n\n## Estimating $p$ the Bayesian way\n\n A binomial experiment with 8 trials  produces the following results: success, failure, success, success, failure, success, success, success. (Each result is therefore a Bernoulli trial.) The person who gave you the data says that the success probability is most likely somewhere near 0.5, but might be near 0 or 1. The aim of this question is to estimate the success probability using Bayesian methods.\n\nIn this question, use `cmdstanr` (see [this site](https://mc-stan.org/cmdstanr/articles/cmdstanr.html) for instructions). Documentation for Stan is [here](https://mc-stan.org/docs/2_26/reference-manual/index.html). You will probably want to be running R on your own computer.\n\n\n\n(a) Write a Stan program that will estimate the success probability $p$. To do this, start with the likelihood (Stan has a function `bernoulli` that takes one parameter, the success probability). The data, as 1s and 0s, will be in a vector `x`. Use a beta distribution with unknown parameters as a prior for `p`. (We will worry later what those parameters should be.)\n\n\n\n(b) Compile your code, correcting any errors until it compiles properly. \n\n\n\n(c) The person who brought you the data told you that the success probability `p` should be somewhere near 0.5 (and is less likely to be close to 0 or 1). Use this information to pick a prior distribution for `p`. (The exact answer you get doesn't really matter, but try to interpret the statement in some kind of sensible way.)\n\n\n\n\n\n(d) Create an R `list` that contains all your `data` for your Stan model. Remember that Stan expects the data in `x` to be 0s and 1s.\n\n\n\n(e) Run your Stan model to obtain a simulated posterior distribution, using all the other defaults.\n\n\n\n(f) Make a plot of the posterior distribution of the probability of success. (Use the `posterior` and `bayesplot` packages if convenient.)\n\n\n\n(g) The posterior predictive distribution is rather odd here: the only possible values that can be observed are 0 and 1. Nonetheless, obtain the posterior predictive distribution for these data, and explain briefly why it is not surprising that it came out as it did.\n\n\n\n\n\n\n\n\n\nMy solutions follow:\n\n\n\n\n##  Estimating proportion in favour from a survey\n\n\n You are probably familiar with the kind of surveys where you are given a statement, like \"I am the kind of person that finishes a task they start\", \nand you have to express your agreement or disagreement with it. \nUsually, you are given a five-point or seven-point scale on which you express your level of agreement (from \"strongly agree\" \nthrough \"neither agree nor disagree\" to \n\"strongly disagree\", for example). Here, we will simplify things a little and only allow respondents to agree or disagree. \nSo the kind of data you would have is a number of people that took part, and the number of these that said \"agree\".\n\nCommon assumptions that are made in this kind of analysis are:\n(i) the responses are independent of each other, and (ii) each respondent has the same unknown probability of agreeing. \nYou might quibble about (ii), but the assumption we are making here is that we know *nothing* about the respondents apart from whether they agreed or disagreed. \n(In practice, we'd collect all kinds of demographic information about each respondent, and this might give us a clue about how they'll respond, but here we're keeping it simple.)\nUnder our assumptions, the number of respondents that agree has a binomial distribution with $n$ being our sample size, and $p$ being the probability we are trying to estimate. Let's estimate $p$ using Stan: that is to say, let's obtain the posterior distribution of $p$.\n\n\n\n(a) In R Studio, open a new Stan file (with File, New File, Stan File). \nYou'll see a template file of Stan code. \nEdit the `model` section to reflect that you have observed a number of successes `x` that we are modelling to have a binomial distribution with number of trials `n` and success probability `p`.\n\nSolution\n\n\nThis is quicker to do than to ask for. Make a guess at this:\n\n\n```\n\nmodel {\n  // likelihood\n  x ~ binomial(n, p);\n}\n```\n\n\nand then check the manual [link](https://mc-stan.org/docs/2_18/functions-reference/binomial-distribution.html), looking for Sampling Statement, to make sure that this is what is expected. It is.\n(I got to this page by googling \"Stan binomial distribution\".)\n\nThe \"likelihood\" line with the two slashes is a comment, C++ style. \nIt is optional, but I like to have it to keep things straight.\n\n$\\blacksquare$\n\n(b) In the line of Stan code you wrote, there should be three variables.\nWhich of these are parameters and which are data? Explain briefly.\n\nSolution\n\n\nThe way to think about this is to ask yourself which of `x`, `n`, and `p` are being given to the Stan code as data, and which you are trying to estimate.\nThe only thing we are estimating here is `p`, so that is a parameter. \nThe number of trials `n` and the number of successes `x` are data that you will observe (treated as \"given\" or \"fixed\" in the Bayesian framework). \n\n$\\blacksquare$\n\n(c) I hope you found that there is only one parameter, `p`, in this problem. We know that $0 \\le p \\le 1$, and we need a prior distribution for it. A common choice is a beta distribution. \nLook at the Stan manual, [link](https://mc-stan.org/docs/2_18/functions-reference/beta-distribution.html). \nThe density function is given in 19.1.1. \nIt has two parameters $\\alpha>0$ and $\\beta>0$. $B(\\alpha, \\beta)$ given there is a constant. \nAdd to your `model` section to express that `p` has a prior distribution with parameters `alpha` and `beta`. \n(`alpha` and `beta` will be input data when we run this code.)\n\nSolution\n\n\nYour `model` section should now look like this:\n\n\n```\n\nmodel {\n  // prior\n  p ~ beta(alpha, beta);\n  // likelihood\n  x ~ binomial(n, p);\n}\n\n```\n\n\n$\\blacksquare$\n\n(d) Above your `model` section, complete a `parameters` section that says what kind of variable `p` is.\nIf `p` has upper or lower limits, put these in as well.\nYou can edit the `parameters` section that is in the template.\n\nSolution\n\n\n`p` is a real variable taking values between 0 and 1, so this:\n\n\n```\n\nparameters {\n  real<lower=0, upper=1> p;\n}\n\n```\n\n\n$\\blacksquare$\n\n(e) Everything else is `data`. Complete a `data` section (edit the one in the template) to say what type of thing everything else is, including limits if it has any. \nDon't forget the parameters in the prior distribution!\n\nSolution\n\n\nWe said before that `n` and `x` were (genuine) data. These are positive integers; also `x` cannot be bigger than `n` (why not?). \nIn the data section also go the parameters `alpha` and `beta` of the prior distribution. These are real numbers bigger than zero.\nThese two together give us this:\n\n\n```\n\ndata {\n  int<lower=0> n;\n  int<lower=0, upper=n> x;\n  real<lower=0> alpha;\n  real<lower=0> beta;\n}\n\n```\n\n\nPutting in lower and upper limits, if you have them, will help because if you happen to enter data that does not respect the limits, you'll get an error right there, and you won't waste time sampling. \n\nIt is more important to put in limits in the `parameters` section, because that is telling the sampler not to go there (eg. a value of $p$ outside $[0,1]$). \n\n\n$\\blacksquare$\n\n(f) Save your code, if you haven't already. I used the filename `binomial.stan`. \nIn your Stan code window, at the top right, you'll see a button marked Check. This checks whether your code is syntactically correct. Click it.\n\n\nSolution\n\n\nThis appeared in my console:\n\n```\n\n> rstan:::rstudio_stanc(\"binomial.stan\")\nbinomial.stan is syntactically correct.\n\n```\n\nIf you don't see this, there is some kind of code error. \nYou'll then see some output that points you to a line of your code. The error is either there or at the end of the previous line (eg. you forgot a semicolon). \nHere is a typical one:\n\n```\n\n> rstan:::rstudio_stanc(\"binomial.stan\")\nSYNTAX ERROR, MESSAGE(S) FROM PARSER:\nerror in 'model377242ac03ef_binomial' at line 24, column 0\n-------------------------------------------------\n22: parameters {\n23:   real<lower=0, upper=1> p\n24: }\n^\n25: \n-------------------------------------------------\n\nPARSER EXPECTED: \";\"\nError in stanc(filename, allow_undefined = TRUE) : \nfailed to parse Stan model 'binomial' due to the above error.\n\n```\n\nThe compiler (or at least the code checker) was expecting a semicolon, and when it got to the close-curly-bracket on line 24, that was where it knew that the semicolon was missing (and thus it objected there and not earlier).\n\nThe above was on my own computer. When I tried it on `r.datatools`, I thought I had everything correct but I got an error message like this:\n\n\n```\n\nError in sink(type = \"output\") : invalid connection\n\n```\n\n\nthat I couldn't get rid of. This might happen to you also.\n\nIf you get an error (other than the above), fix it and check again. Repeat until your code is \"syntactically correct\". \n(That means that it will compile, but not that it will necessarily do what you want.)\nThis process is an integral part of coding, so get used to it. \nIt doesn't matter how many errors you make; what matters is that you find and correct them all. \n\n\n$\\blacksquare$\n\n(g) Compile your model. (This may take a minute or so, depending on how fast your \nR Studio is.) When the spinny thing stops spinning, it's done.\n\n\nSolution\n\n\nGo down to the console and type something like\n\n::: {.cell}\n\n```{.r .cell-code}\nbinomial <- cmdstan_model(\"binomial.stan\")\n```\n:::\n\n   \n\nIf it doesn't work, make sure you installed and loaded `cmdstanr` first, with `install.packages` and `library` respectively.\n\nIf it sits there and does nothing for a while, this is actually a good sign. If it finds an error, it will tell you. If you get your command prompt `>` back without it saying anything, that means it worked. (This is a Unix thing: no comment means no error.)\n\nIf you happen to compile it a second time, without changing anything in the Stan code, it won't make you wait while it compiles again: it will say \"Model executable is up to date!\".\n\n$\\blacksquare$\n\n(h) In most surveys, the probability to be estimated is fairly close to 0.5. \nA beta prior with $\\alpha=\\beta=2$ expresses the idea that any value of `p` is possible, but values near 0.5 are more likely.\n\nA survey of 277 randomly selected adult female shoppers was taken. 69 of them agreed that when an advertised item is not available at the local supermarket, they request a raincheck.\n\nUsing the above information, set up a data `list` suitable for input to a run of `stan`.\n\n\nSolution\n\n\nLook in your `data` section, and see what you need to provide values for. \nThe order doesn't matter; make a list with the named pieces and their values, in some order. You need values for these four things:\n\n::: {.cell}\n\n```{.r .cell-code}\nbinomial_data <- list(n = 277, x = 69, alpha = 2, beta = 2)\n```\n:::\n\n   \n\nExtra: in case you are wondering where the parameters for the prior came from: in this case, I looked on the Wikipedia page for the beta distribution and saw that $\\alpha=\\beta=2$ is a good shape, so I used that. \nIn practice, getting a reasonable prior is a more difficult problem, called \"elicitation\". \nWhat you have to do is ask a subject matter expert what they think `p` might be, giving you a range of values such as a guessed-at 95% confidence interval, like \"I think `p` is almost certainly between 0.1 and 0.6\". \nThen *you* as a statistician have to choose values for `alpha` and `beta` that match this, probably by trial and error. \nThe `beta` distribution is part of R, so this is doable, for example like this:\n\n::: {.cell}\n\n```{.r .cell-code}\ncrossing(alpha = 1:10, beta = 1:10) %>%\n  mutate(\n    lower = qbeta(0.025, alpha, beta),\n    upper = qbeta(0.975, alpha, beta)\n  ) %>%\n  mutate(sse = (lower - 0.1)^2 + (upper - 0.6)^2) %>%\n  arrange(sse)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 x 5\n   alpha  beta  lower upper      sse\n   <int> <int>  <dbl> <dbl>    <dbl>\n 1     4     8 0.109  0.610 0.000181\n 2     3     7 0.0749 0.600 0.000632\n 3     4     9 0.0992 0.572 0.000793\n 4     5    10 0.128  0.581 0.00112 \n 5     5     9 0.139  0.614 0.00169 \n 6     3     6 0.0852 0.651 0.00280 \n 7     3     8 0.0667 0.556 0.00303 \n 8     4     7 0.122  0.652 0.00322 \n 9     4    10 0.0909 0.538 0.00391 \n10     6    10 0.163  0.616 0.00428 \n# i 90 more rows\n```\n\n\n:::\n:::\n\n(`crossing`) does all possible combinations of its inputs; `expand.grid` would also do the same thing.)\n\nThis says that $\\alpha=4, \\beta=8$ is a pretty good choice.^[Alpha and beta don't have to be integers; you could use *seq* to create sequences of values for alpha and beta that include decimal numbers.]\n\nMy process:\n\n\n* Pick some values of `alpha` and `beta` to try, and make all possible combinations of them.\n\n* Find the 2.5 and 97.5 percentiles of the beta distribution for each of those values. \nThe \"inverse CDF\" (the value $x$ that has this much of the probability below it) is what we want here; this is obtained in R by putting `q` in front of the name of the distribution. For example, does this make sense to you?\n\n::: {.cell}\n\n```{.r .cell-code}\nqnorm(0.025)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.959964\n```\n\n\n:::\n:::\n\n  \n\n* We want the lower limit to be close to 0.1 *and* the upper limit to be close to 0.6. Working out the sum of squared errors for each `alpha`-`beta` combo is a way to do this; if `sse` is small, that combination of `alpha` and `beta` gave lower and upper limits close to 0.1 and 0.6.\n\n* Arrange the `sse` values smallest to largest. The top rows are the best choices of `alpha` and `beta`.\n\n\n\n$\\blacksquare$\n\n(i) Sample from the posterior distribution of `p` with these data, and display your results.\n\n\nSolution\n\n\n\n   \nThis is what I got:\n\n::: {.cell}\n\n```{.r .cell-code}\nbinomial_fit <- binomial$sample(binomial_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.0 seconds.\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 0.0 seconds.\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 0.0 seconds.\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.7 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nbinomial_fit\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n variable    mean  median   sd  mad      q5     q95 rhat ess_bulk ess_tail\n     lp__ -159.33 -159.07 0.69 0.32 -160.72 -158.84 1.00     1831     2616\n     p       0.25    0.25 0.03 0.03    0.21    0.29 1.00     1387     1995\n```\n\n\n:::\n:::\n\n   \n\nYour results should be similar, though probably not identical, to mine. (There is a lot of randomness involved here.)\n\n\n$\\blacksquare$\n\n(j) Obtain a 90\\% posterior interval for the probability that a randomly chosen adult female shopper will request a raincheck.\n\n\nSolution\n\n\nRead off the `q5` and `q95` values for `p`. Mine are 0.21 and 0.29.\n\n\n$\\blacksquare$\n\n(k) Obtain a 95\\% (frequentist) confidence interval for `p`, and compare the results. (Hint: `prop.test`.) Comment briefly.\n\n\nSolution\n\n\nIf you remember this well enough, you can do it by hand, but there's no need:\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.test(69, 277)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n\t1-sample proportions test with continuity correction\n\ndata:  69 out of 277, null probability 0.5\nX-squared = 68.751, df = 1, p-value < 2.2e-16\nalternative hypothesis: true p is not equal to 0.5\n95 percent confidence interval:\n 0.2001721 0.3051278\nsample estimates:\n        p \n0.2490975 \n```\n\n\n:::\n:::\n\n   \n\nMy 95\\% intervals are very close.\n\nNumerically, this is because the only (material) difference between\nthem is the presence of the prior in the Bayesian approach. We have\nquite a lot of data, though, so the choice of prior is actually not\nthat important (\"the data overwhelm the prior\"). I could have used\n`alpha=8, beta=4` that I obtained in the Extra above, and it\nwouldn't have made any noticeable difference.\n\nConceptually, though, the interpretations of these intervals are very\ndifferent: the Bayesian posterior interval really does say \n\"the probability of $p$ being between 0.20 and 0.31 is 0.95\", while for the\nconfidence interval you have to talk about repeated sampling: \n\"the procedure producing the 95\\% confidence interval will contain the true value of $p$ in 95\\% of all possible samples\".  This might seem\nclunky in comparison; a Bayesian would tell you that the\ninterpretation of the posterior interval is what you want the\ninterpretation of the confidence interval to be!\n\n\n$\\blacksquare$\n\n(l) (optional) This is one of those problems where you can obtain the answer analytically. What is the posterior distribution of $p$, using a prior $beta(\\alpha, \\beta)$ distribution for $p$ and observing $x$ successes out of $n$ trials?\n\n\nSolution\n\n\nWith this stuff, you can throw away any constants.\n\nThe likelihood is (proportional to) $$ p^x (1-p)^{n-x}.$$ There is a binomial coefficient that I threw away.\n\nLook up the form of the beta density if you don't know it (or look above): the prior for $p$ is proportional to\n\n$$ p^{\\alpha-1} (1-p)^{\\beta-1}.$$\n\nPosterior is proportional to likelihood times prior:\n\n$$ p^{x + \\alpha - 1} (1-p)^{n-x +\\beta - 1}$$\n\nwhich is recognized as a beta distribution with parameters $x+\\alpha$, $n-x+\\beta$. \nTypically (unless you are very sure about $p$ a priori (that is, before collecting any data)), $x$ and $n-x$ will be much larger than $\\alpha$ and $\\beta$, so this will look a lot like a binomial likelihood, which is why the confidence interval and posterior interval in our example came out very similar.\nI leave it to you to decide which you prefer: algebra and\nintelligence (and luck, often), or writing code to sample from the\nposterior. I know what I prefer!\n\nExtra: one of the people behind Stan is on Twitter with handle `@betanalpha`.\n\n$\\blacksquare$\n\n\n\n\n##  Bayesian regression\n\n\n In this question, we will develop Stan code to run a simple\nlinear regression, and later apply it to some data (and do a bit of\nelicitation of prior distributions along the way).\n\n\n\n(a) Create a `.stan` file that will run a simple linear\nregression predicting a variable `y` from a variable\n`x`, estimating an intercept `a` and a slope\n`b`. Use normal prior distributions for `a` and\n`b`, and allow the means and SDs of the prior distributions\nfor `a` and `b` to be specified (as data, later). The\nregression model says that the response `y` has a normal\ndistribution with mean `a+bx` and SD `sigma` which is\nalso estimated. Give this a prior chi-squared distribution with a\nprior mean that is also input.\n\nSolution\n\n\nThis is a lot. Breathe. Pause. Then, in R Studio, File, New File and Stan File. Leave the template there, and change what you need as you go.\nI would start with the model part. The likelihood part says that `y` has a normal distribution with mean `a+bx` and SD `sigma`, thus:\n\n```\n\n// likelihood\ny ~ normal(a+b*x, sigma);\n\n```\n\nThere is a subtlety here that I'll get to later, but this is the easiest way to begin.\nNext, take a look at what's here. `x` and `y` are\ndata, and the other things, `a`, `b`, `sigma`\nare parameters. These last three need prior distributions. I said\nto use normal distributions for the first two, and a chi-squared\ndistribution for the last one. (In practice, of course, you get to\nchoose these, in consultation with the subject matter expert, but\nthese are likely to be pretty reasonable.) I've given the\nparameters of these prior distributions longish names, so I hope\nI'm trading more typing for less confusion:\n\n```\n\nmodel {\n  // prior\n  a ~ normal(prior_int_mean, prior_int_sd);\n  b ~ normal(prior_slope_mean, prior_slope_sd);\n  sigma ~ chi_square(prior_sigma_mean);\n  // likelihood\n  y ~ normal(a+b*x, sigma);\n}\n\n```\n\nThe chi-squared distribution is written that way in Stan, and has\nonly one parameter, a degrees of freedom that is also its mean.\n\nOur three parameters then need to be declared, in the\n`parameters` section. `a` and `b` can be any\nreal number, while `sigma` has to be positive:\n\n```\n\nparameters {\n  real a;\n  real b;\n  real<lower=0> sigma;\n}\n\n```\n\n\nEverything else is data, and we have a *lot* of data this time:\n\n\n```\n\ndata {\n  int<lower=0> n;\n  vector[n] x;\n  vector[n] y;\n  real prior_int_mean;\n  real<lower=0> prior_int_sd;\n  real prior_slope_mean;\n  real<lower=0> prior_slope_sd;\n  real<lower=0> prior_sigma_mean;\n}\n\n```\n\n\nThe five things at the bottom are the prior distribution parameters,\nwhich we are going to be eliciting later. The means for intercept and\nslope can be anything; the prior SDs have to be positive, and so does\nthe prior mean for `sigma`, since it's actually a degrees of\nfreedom that has to be positive.\n\nNow we come to two pieces of subtlety. The first is that the\n`x` and `y` are going to have some (unknown) number of\nvalues in them, but we need to declare them with some length. The\nsolution to that is to have the number of observations `n` also\nbe part of the data. Once we have that, we can declare `x` and\n`y` to be of length `n` with no problems.\n\nThe second piece of subtlety is that you were probably expecting this:\n\n\n```\n\nreal x[n];\nreal y[n];\n\n```\n\n\nThis is usually what you need, but the problem is that when you work\nout `a+b*x` later on, it *doesn't work* because you are\ntrying to multiply an array of values `x` by a single value\n`b`. (Try it.) There are two ways around this: (i), if you\ninstead declare `x` and `y` to be (real) vectors of\nlength `n`, Stan borrows from R's multiplication of a vector by\na scalar and it works, by multiplying *each element* of the\nvector by the scalar. Or, (ii), you can go back to declaring\n`x` and `y` as real things of length `n`, and use\na loop to get *each* y from its corresponding `x`, like\nthis:\n\n\n```\n\nfor (i in 1:n) {\n  y[i] ~ normal(a + b * x[i], sigma)\n}\n\n\n```\n\n\nand this works because `a`, `b`, and `x[i]` are\nall scalar. I have to say that I don't really understand the\ndistinction between `real x[n]` and `vector[n] x`,\nexcept that sometimes one works and the other doesn't.\n\nThe manual tells you that the `vector` way is \"much faster\",\nthough in a simple problem like this one I doubt that it makes any\nnoticeable difference.\n\nMy code looks like this, in total:\n\n\n```\n\ndata {\n  int<lower=0> n;\n  vector[n] x;\n  vector[n] y;\n  real prior_int_mean;\n  real<lower=0> prior_int_sd;\n  real prior_slope_mean;\n  real<lower=0> prior_slope_sd;\n  real<lower=0> prior_sigma_mean;\n}\n\nparameters {\n  real a;\n  real b;\n  real<lower=0> sigma;\n}\n\nmodel {\n  // prior\n  a ~ normal(prior_int_mean, prior_int_sd);\n  b ~ normal(prior_slope_mean, prior_slope_sd);\n  sigma ~ chi_square(prior_sigma_mean);\n  // likelihood\n  y ~ normal(a+b*x, sigma);\n}\n\n\n```\n\n$\\blacksquare$\n\n(b) Check your Stan code for syntactic correctness, and when it is\ncorrect, compile it.\n\nSolution\n\n\nClick the Check button top right of the window where your Stan\ncode is. If it finds any errors, correct them and try again.\n\nTo compile, the usual thing:\n\n::: {.cell}\n\n```{.r .cell-code}\nreg <- cmdstan_model(\"reg.stan\")\n```\n:::\n\n \n\nand wait for it to do its thing. With luck, Check will have found all\nthe errors and this will quietly (eventually) do its job.\n\n$\\blacksquare$\n\n(c) We are going to be analyzing some data on vocabulary size (the number of words known) by children of different ages. It is suspected that the relationship between age and vocabulary size is approximately linear.\nYou go consult with an early childhood expert, and they tell you this:\n\n\n* In children of age up to about six, vocabulary almost always\nincreases by between 300 and 700 words per year.\n\n* I can't talk about vocabulary of children of age 0, because children don't start learning to talk until age about 18 months (1.5 years).\n\n* Children of age 1.5 years almost always have a vocabulary\nbetween 0 and 500 words (depending on exactly what age they\nstarted talking.)\n\n* Even if we know a child's age, our prediction of their\nvocabulary size might be off by as much as 200 words.\n\nUse this information to obtain parameters for your prior distributions.\n\nSolution\n\n\nThis is the typical kind of way in which you would elicit a prior\ndistribution; you try to turn what the expert tells you into\nsomething you can use.\n\nLet's assume that the \"almost always\" above corresponds to a\n95\\% confidence interval, and since our intercept and slope have\nprior normal distributions, this is, to the accuracy that we are\nworking, mean plus/minus 2 SD. (You can make different assumptions\nand you'll get a somewhat different collection of prior\ndistributions.)\n\nThe first statement talks about the change in vocabulary size per\nyear. This is talking about the slope. The supposed 95\\%\nconfidence interval given translates to $500 \\pm 2(100)$, so the\nprior mean for the slope is 500 and the prior SD is 100.\n\nNot so hard. The problems start with the second one. \n\nWe want a prior mean and SD for the intercept, that is, for the\nmean and SD of vocabulary size at age 0, but the expert (in their\nsecond statement) is telling us this makes no sense. The third\nstatement says that at age 1.5, a 95\\% CI for vocabulary size is\n$250 \\pm 2(125)$. You can go a number of different ways from here,\nbut a simple one is use our best guess for the slope, 500, to\nproject back 1.5 years from here by decreasing the mean by\n$(500)(1.5)=750$, that is, to $-500 \\pm 2(125)$.\n\nThe last one we need is the prior mean for `sigma`. This is what\nthe last statement is getting at. Up to you whether you think this\nis an estimate of `sigma` or twice sigma. Let's take 200 as\na prior estimate of `sigma`, to be safe.\n\nYou see that getting a useful prior depends on asking the right\nquestions and making good use of the answers you get.\n\nSome people like to use \"ignorance\" priors, where you assign equal\nprobability to all possible values of the parameter. I don't, because\nthese are saying that a slope of 10 million is just as likely as a\nslope of 1, regardless of the actual circumstances; you will almost\nalways have *some* idea of what you are expecting. It might be\nvague, but it won't be infinitely vague.\n\n$\\blacksquare$\n\n(d) Some data were collected on age and vocabulary size of 10\nrandomly selected children, shown here:\n[link](http://ritsokiguess.site/pasias/vocab.txt). Read\nin and display the data; the values are separated by single spaces.\n\nSolution\n\n\nThus:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/vocab.txt\"\nvocabulary <- read_delim(my_url, \" \")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 10 Columns: 2\n-- Column specification --------------------------------------------------------\nDelimiter: \" \"\ndbl (2): age, vocab\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nvocabulary\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 2\n     age vocab\n   <dbl> <dbl>\n 1   1.5   100\n 2   2     250\n 3   2.5   460\n 4   3     890\n 5   3.5  1210\n 6   4    1530\n 7   4.5  1840\n 8   5    2060\n 9   5.5  2300\n10   6    2500\n```\n\n\n:::\n:::\n\n     \n$\\blacksquare$\n\n(e) Use this dataset, along with your prior distribution from\nabove, to obtain posterior distributions for intercept, slope and\nerror SD. What is the 95\\% posterior interval for the slope?\n\nSolution\n\n\nTwo parts: set up the data, and then sample it:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreg_data <- list(\n  n = 10, x = vocabulary$age, y = vocabulary$vocab,\n  prior_int_mean = -500,\n  prior_int_sd = 125,\n  prior_slope_mean = 500,\n  prior_slope_sd = 100,\n  prior_sigma_mean = 200\n)\nreg.1 <- reg$sample(reg_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.1 seconds.\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 0.1 seconds.\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 0.1 seconds.\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 0.1 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.1 seconds.\nTotal execution time: 0.5 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nreg.1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n variable    mean  median    sd   mad      q5     q95 rhat ess_bulk ess_tail\n    lp__   373.72  374.02  1.23  0.97  371.33  375.04 1.00     1865     2471\n    a     -612.38 -611.41 98.80 99.22 -771.84 -450.69 1.01     1527     1953\n    b      520.07  519.64 27.07 26.84  475.85  564.71 1.01     1397     1588\n    sigma  189.08  188.23 18.92 19.24  158.77  221.09 1.00     2163     1967\n```\n\n\n:::\n:::\n\n \n\nOne line per parameter (plus the log-posterior distribution, not very useful to us). To get a 95\\% posterior interval for the slope, use the 2.5 and 97.5 percentiles of the posterior for `b`, which are 467 and 572. (This is about $520 \\pm 52$, rounding crudely, while the prior distribution said $500 \\pm 200$, so the data have allowed us to estimate the slope a fair bit more accurately.)\n\n$\\blacksquare$\n\n(f) Plot a histogram of the posterior distribution of the slope. Does its shape surprise you? Explain briefly.\n\n\nSolution\n\nThis is most easily `mcmc_hist` from `bayesplot`:\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_hist(reg.1$draws(\"b\"), binwidth = 20)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/regression-stan-4-1.pdf){fig-pos='H'}\n:::\n:::\n\nI'm guessing you have a better intuition for `bins` as opposed to `binwidth` (the latter being what you need here), so you can try it without giving a `binwidth` at all (and getting way too many bins), and then see if you can figure out what `binwidth` should be to get you a sensible number of bins. This one looks pretty good to me. \n\nThe shape is very normal. This is because everything is normal: the prior and the data-generating process both, so it is not surprising at all that the posterior came out normal. (You may remember from your regression course that if you have a normal regression model, the slope also has a normal distribution.)\n\n$\\blacksquare$\n\n(g) What can we say about the vocabulary size of a randomly\nselected child of age 5 (a new one, not the one in the original data\nset)? Use an appropriate predictive distribution.\n\nSolution\n\n\nIf you have done a regression course, you might recognize this as being the Bayesian version of a prediction interval. How might we make a predictive distribution for this? Well, first we need to extract the sampled values from the posteriors:\n\n::: {.cell}\n\n```{.r .cell-code}\nas_draws_df(reg.1$draws()) %>%\n  as_tibble() -> sims\nsims\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 7\n    lp__     a     b sigma .chain .iteration .draw\n   <dbl> <dbl> <dbl> <dbl>  <int>      <int> <int>\n 1  373. -694.  566.  180.      1          1     1\n 2  373. -657.  560.  199.      1          2     2\n 3  374. -660.  537.  208.      1          3     3\n 4  373. -628.  542.  224.      1          4     4\n 5  374. -609.  505.  208.      1          5     5\n 6  375. -627.  517.  206.      1          6     6\n 7  375. -683.  531.  169.      1          7     7\n 8  373. -671.  527.  223.      1          8     8\n 9  373. -673.  544.  154.      1          9     9\n10  373. -646.  536.  231.      1         10    10\n# i 3,990 more rows\n```\n\n\n:::\n:::\n\n \n\nand now we need to simulate some response values for our notional child of age 5. That means simulating for an `x` of 5, using each of those values of `a`, `b` and `sigma`:\n\n::: {.cell}\n\n```{.r .cell-code}\nsims %>%\n  rowwise() %>% \n  mutate(sim_vocab = rnorm(1, a + b * 5, sigma)) -> sims2\nsims2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 8\n# Rowwise: \n    lp__     a     b sigma .chain .iteration .draw sim_vocab\n   <dbl> <dbl> <dbl> <dbl>  <int>      <int> <int>     <dbl>\n 1  373. -694.  566.  180.      1          1     1     2053.\n 2  373. -657.  560.  199.      1          2     2     1632.\n 3  374. -660.  537.  208.      1          3     3     2430.\n 4  373. -628.  542.  224.      1          4     4     1930.\n 5  374. -609.  505.  208.      1          5     5     2034.\n 6  375. -627.  517.  206.      1          6     6     1573.\n 7  375. -683.  531.  169.      1          7     7     2054.\n 8  373. -671.  527.  223.      1          8     8     1975.\n 9  373. -673.  544.  154.      1          9     9     1824.\n10  373. -646.  536.  231.      1         10    10     2235.\n# i 3,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nggplot(sims2, aes(x = sim_vocab)) + geom_histogram(bins = 20)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/regression-stan-6-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nThat's the distribution of the vocabulary size of children aged 5. We can get a 95\\% interval from this the usual way: find the 2.5 and 97.5 percentiles:\n\n::: {.cell}\n\n```{.r .cell-code}\nwith(sims2, quantile(sim_vocab, c(0.025, 0.975)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    2.5%    97.5% \n1579.193 2383.120 \n```\n\n\n:::\n:::\n\n \n\nThe actual child of age 5 that we observed had a vocabulary of 2060\nwords, squarely in the middle of this interval.\n\nIs the posterior predictive interval like the prediction interval?\n\n::: {.cell}\n\n```{.r .cell-code}\nvocabulary.1 <- lm(vocab ~ age, data = vocabulary)\nnew <- tibble(age = 5)\npredict(vocabulary.1, new, interval = \"p\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       fit      lwr      upr\n1 2027.939 1818.223 2237.656\n```\n\n\n:::\n:::\n\n \n\nIt seems a bit wider.\n\n$\\blacksquare$\n\n\n\n\n## Estimating $p$ the Bayesian way\n\n A binomial experiment with 8 trials  produces the following results: success, failure, success, success, failure, success, success, success. (Each result is therefore a Bernoulli trial.) The person who gave you the data says that the success probability is most likely somewhere near 0.5, but might be near 0 or 1. The aim of this question is to estimate the success probability using Bayesian methods.\n\nIn this question, use `cmdstanr` (see [this site](https://mc-stan.org/cmdstanr/articles/cmdstanr.html) for instructions). Documentation for Stan is [here](https://mc-stan.org/docs/2_26/reference-manual/index.html). You will probably want to be running R on your own computer.\n\n\n\n(a) Write a Stan program that will estimate the success probability $p$. To do this, start with the likelihood (Stan has a function `bernoulli` that takes one parameter, the success probability). The data, as 1s and 0s, will be in a vector `x`. Use a beta distribution with unknown parameters as a prior for `p`. (We will worry later what those parameters should be.)\n\nSolution\n\n\nFile, New and Stan. Leave the template program there if you like, as a reminder of what to do. In the `model` section is where the likelihood goes, like this:^[The comment line, with two slashes on the front, is optional but will help you keep track of what's what.]\n\n```\nmodel {\n// likelihood\nx ~ bernoulli(p);\n}\n```\n\nThe right one here is `bernoulli` since your data are Bernoulli trials (successes and failures, coded as 1s and 0s). If you had a summarized total number of successes and a number of trials, then that would be binomial. It actually doesn't make any difference which way you do it, but it's probably easier to think about it this way because it's more like the Poisson one in lecture. \n\n\nThinking ahead, `x` is going to be data, and `p` is a parameter, so `p` will need a prior distribution.  The standard one for a Bernoulli success probability is a beta distribution. This is actually the conjugate prior, if you have learned about those: if `p` has a beta prior and the likelihood is Bernoulli, then the posterior is also beta. Back in the days when algebra was your only hope for this kind of thing, conjugate priors were very helpful, but now that we can sample from any posterior, the fact that a prior is conjugate is neither here nor there. Having said that, the beta distribution is a nice choice for a prior for this, because it is restricted to $[0, 1]$ the same way that a Bernoulli `p` is. \n\nI'm going leave the prior parameters for `p` unknown for now; we'll just call them `a` and `b`.^[We'll come back later to the question of what a and b should be for our situation.] Here's our completed `model` section:\n\n```\nmodel {\n// prior\np ~ beta(a, b);\n// likelihood\nx ~ bernoulli(p);\n}\n```\n\n`a` and `b` are not parameters; they are some numbers that we will supply, so they will be part of the `data` section. Leaving them unspecified like this, rather than hard-coding them, is good coding practice, since the code we finish with can be used for any Bernoulli estimation problem, not just the one we happen to have. \n\nThere is only one parameter, `p`, so the `parameters` section is short:\n\n```\nparameters {\nreal<lower=0,upper=1> p;\n}\n```\n\nWe know that `p` must be between 0 and 1, so we specify that here so that the sampler doesn't stray into impossible values for `p`. \n\nThat goes before the `model` section. Everything else is data. We also want to avoid hard-coding the number of observations, so we will also have an `n` as data, which we declare first, so we can declare the array of values `x` to be of length `n`:\n\n```\ndata {\nint<lower=0> n;\nreal a;\nreal b;\nint<lower=0, upper=1> x[n];\n}\n```\n\n`x` is an integer array of length `n`. This is how you declare one of those: the type is first, along with any limits, and then the length of the array is appended in square brackets to the name of the array.\n\nArrange your code in a file with extension `.stan`, with data first, parameters second, and model third. I called mine `bernoulli.stan`.\n\nExtra: there are two ways to declare a *real*-valued array `y`: as `real y[n]`, or as `vector[n] y`. Sometimes it matters which way you do it (and I don't have a clear sense of when it matters). The two ways differ in what you can do with them.\n\n\n$\\blacksquare$\n\n\n(b) Compile your code, correcting any errors until it compiles properly. \n\nSolution\n\n\n\n::: {.cell}\n\n:::\n\n\n`cmdstanr` goes like this:\n\n\n\n::: {.cell}\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm2 <- cmdstan_model(\"bernoulli.stan\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nm2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ndata {\n  int<lower=0> n;\n  real a;\n  real b;\n  array[n] int<lower=0, upper=1> x;\n}\n\nparameters {\n  real<lower=0,upper=1> p;\n}\n\nmodel {\n  // prior\n  p ~ beta(a, b);\n  // likelihood\n  x ~ bernoulli(p);\n}\n```\n\n\n:::\n:::\n\n\nIf it doesn't compile, you have some fixing up to do. The likely first problem is that you have missed a semicolon somewhere. The error message will at least give you a hint about where the problem is. Fix any errors you see and try again. If you end up with a different error message, that at least is progress.\n\n\n$\\blacksquare$\n\n\n(c) The person who brought you the data told you that the success probability `p` should be somewhere near 0.5 (and is less likely to be close to 0 or 1). Use this information to pick a prior distribution for `p`. (The exact answer you get doesn't really matter, but try to interpret the statement in some kind of sensible way.)\n\n\nSolution\n\n\nI don't know how much intuition you have for what beta distributions look like, so let's play around a bit. Let's imagine we have a random variable $Y$ that has a beta distribution. This distribution has two parameters, usually called $a$ and $b$. Let's draw some pictures and see if we can find something that would serve as a prior. R has `dbeta` that is the beta distribution density function.\n\nStart by choosing some values for $Y$:\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- seq(0, 1, 0.01)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [1] 0.00 0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14\n [16] 0.15 0.16 0.17 0.18 0.19 0.20 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29\n [31] 0.30 0.31 0.32 0.33 0.34 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44\n [46] 0.45 0.46 0.47 0.48 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59\n [61] 0.60 0.61 0.62 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74\n [76] 0.75 0.76 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89\n [91] 0.90 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00\n```\n\n\n:::\n:::\n\nthen work out `dbeta` of these for your choice of parameters, then plot it. I'm going straight to a function for this, since I anticipate doing it several times. This `y` and the two parameters should be input to the function:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta <- function(y, a, b) {\n  tibble(y=y) %>% \n  mutate(density = dbeta(y, a, b)) %>% \n  ggplot(aes(x = y, y = density)) + geom_line()\n}\nplot_beta(y, 1, 1)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-7-1.pdf){fig-pos='H'}\n:::\n:::\n\nThe beta with parameters 1 and 1 is a uniform distribution. (If you look up the beta density function, you'll see why that is.)\n\nLet's try another:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta(y, 3, 2)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-8-1.pdf){fig-pos='H'}\n:::\n:::\n\nThis one is skewed to the left. You might guess that having the second parameter bigger would make it skewed to the right:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta(y, 3, 7)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-9-1.pdf){fig-pos='H'}\n:::\n:::\n\nwhich indeed is the case. If you try some other values, you'll see that this pattern with the skewness continues to hold. Furthermore, the right-skewed distributions have their peak to the *left* of 0.5, and the left-skewed ones have their peak to the *right* of 0.5.\n\nTherefore, you would think, having the two parameters the same would give a symmetric distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta(y, 2, 2)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-10-1.pdf){fig-pos='H'}\n:::\n:::\n\nNote that the peak is now at 0.5, which is what we wanted.\n\nThe question called for a prior distribution of values \"somewhere near 0.5\", and you could reasonably say that this does the job. What does 3 and 3 look like?\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta(y, 3, 3)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-11-1.pdf){fig-pos='H'}\n:::\n:::\n\nThis is more concentrated around 0.5, and as you increase the two parameter values while keeping them equal, it gets more concentrated still:\n\n::: {.cell}\n\n```{.r .cell-code}\nplot_beta(y, 20, 20)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-12-1.pdf){fig-pos='H'}\n:::\n:::\n\nFor our purposes, this is undoubtedly too concentrated around 0.5; there is no chance of $y$ being outside $[0.25, 0.75]$. I would go with parameters 2 and 2 or maybe 3 and 3. As I said, pretty much any choice of parameter values that are both the same is at least somewhat justifiable. \n\nIf you don't want to go through all of this, find some pictures of beta distributions with different parameters, and pick one you like. The [Wikipedia page](https://en.wikipedia.org/wiki/Beta_distribution) is one place (from which you would probably pick 2 and 2). \n[Here is another](https://www.researchgate.net/figure/Beta-distribution-probability-density-function_fig3_220556911), from which you might pick 5 and 5.\n\nIn practice, you would have some back-and-forth with the person who brought you the data, and try to match what they are willing to say about `p`, without looking at the data, to what you know or can find out about the beta distribution. This process is called \"prior elicitation\".\n\nExtra: if you have ever obtained the posterior distribution in this case by algebra, you might recall that the effect of the prior distribution is to add some \"fake\" Bernoulli trials to the data. With $a=b=2$, for example, you imagine $2+2-2 = 2$ fake trials, with $2-1=1$ success and $2-1=1$ failure, to add to the data. This brings the estimate of `p` a little closer to 0.5 than it would be with just plain maximum likelihood.\n\n\n$\\blacksquare$\n\n\n\n(d) Create an R `list` that contains all your `data` for your Stan model. Remember that Stan expects the data in `x` to be 0s and 1s.\n\nSolution\n\n\nTurn those successes and failures in the question into a vector of 0 and 1 values, with 1 being success (you wanted to estimate the probability of success): they were success, failure, success, success, failure, success, success, success.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 0, 1, 1, 0, 1, 1, 1)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0 1 1 0 1 1 1\n```\n\n\n:::\n:::\n\nThen make a \"named list\" of inputs to your Stan program, including the parameter values for the prior distribution (I went with 2 and 2):\n\n::: {.cell}\n\n```{.r .cell-code}\nstan_data <- list(\nn = 8,\na = 2,\nb = 2,\nx = x\n)\nstan_data\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$n\n[1] 8\n\n$a\n[1] 2\n\n$b\n[1] 2\n\n$x\n[1] 1 0 1 1 0 1 1 1\n```\n\n\n:::\n:::\n\n\n\n$\\blacksquare$\n\n\n(e) Run your Stan model to obtain a simulated posterior distribution, using all the other defaults.\n\nSolution\n\nThe `cmdstanr` way:\n\n::: {.cell}\n\n```{.r .cell-code}\nfit2 <- m2$sample(data = stan_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRunning MCMC with 4 sequential chains...\n\nChain 1 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 1 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 1 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 1 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 1 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 1 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 1 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 1 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 1 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 1 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 1 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 1 finished in 0.0 seconds.\nChain 2 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 2 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 2 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 2 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 2 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 2 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 2 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 2 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 2 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 2 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 2 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 2 finished in 0.0 seconds.\nChain 3 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 3 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 3 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 3 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 3 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 3 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 3 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 3 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 3 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 3 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 3 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 3 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 3 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 3 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 3 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 3 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 3 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 3 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 3 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 3 finished in 0.0 seconds.\nChain 4 Iteration:    1 / 2000 [  0%]  (Warmup) \nChain 4 Iteration:  100 / 2000 [  5%]  (Warmup) \nChain 4 Iteration:  200 / 2000 [ 10%]  (Warmup) \nChain 4 Iteration:  300 / 2000 [ 15%]  (Warmup) \nChain 4 Iteration:  400 / 2000 [ 20%]  (Warmup) \nChain 4 Iteration:  500 / 2000 [ 25%]  (Warmup) \nChain 4 Iteration:  600 / 2000 [ 30%]  (Warmup) \nChain 4 Iteration:  700 / 2000 [ 35%]  (Warmup) \nChain 4 Iteration:  800 / 2000 [ 40%]  (Warmup) \nChain 4 Iteration:  900 / 2000 [ 45%]  (Warmup) \nChain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup) \nChain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling) \nChain 4 Iteration: 1100 / 2000 [ 55%]  (Sampling) \nChain 4 Iteration: 1200 / 2000 [ 60%]  (Sampling) \nChain 4 Iteration: 1300 / 2000 [ 65%]  (Sampling) \nChain 4 Iteration: 1400 / 2000 [ 70%]  (Sampling) \nChain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling) \nChain 4 Iteration: 1600 / 2000 [ 80%]  (Sampling) \nChain 4 Iteration: 1700 / 2000 [ 85%]  (Sampling) \nChain 4 Iteration: 1800 / 2000 [ 90%]  (Sampling) \nChain 4 Iteration: 1900 / 2000 [ 95%]  (Sampling) \nChain 4 Iteration: 2000 / 2000 [100%]  (Sampling) \nChain 4 finished in 0.0 seconds.\n\nAll 4 chains finished successfully.\nMean chain execution time: 0.0 seconds.\nTotal execution time: 0.6 seconds.\n```\n\n\n:::\n\n```{.r .cell-code}\nfit2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail\n     lp__ -8.18  -7.88 0.75 0.33 -9.66 -7.64 1.00     1926     2095\n     p     0.67   0.68 0.13 0.14  0.44  0.87 1.00     1371     1602\n```\n\n\n:::\n:::\n\nThis one gives you a 90% posterior interval instead of a 95% one, but the posterior mean is 0.66, as before, and the interval says that `p` is likely bigger than about 0.4; the data did not narrow it down much apart from that.\n\n\n\n$\\blacksquare$\n\n\n(f) Make a plot of the posterior distribution of the probability of success. (Use the `posterior` and `bayesplot` packages if convenient.)\n\nSolution\n\n\nThis means extracting the sampled values of $p$ first. \nThe `cmdstanr` way is not very convenient, at least at first:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2a <- fit2$draws()\nstr(bern.2a)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n 'draws_array' num [1:1000, 1:4, 1:2] -8.38 -9.05 -7.74 -8.44 -9.31 ...\n - attr(*, \"dimnames\")=List of 3\n  ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...\n  ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"\n  ..$ variable : chr [1:2] \"lp__\" \"p\"\n```\n\n\n:::\n:::\n\nThis is a 3-dimensional array (sample by chain by variable). For plotting and so on, we really want this as a dataframe. At this point, I would use the `posterior` and `bayesplot` packages, which you should install following the instructions for `cmdstanr` at the top of [this page](https://mc-stan.org/cmdstanr/articles/cmdstanr.html#running-mcmc-1). Put the names of the extra two packages in place of the `cmdstanr` that you see there.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(posterior)\nlibrary(bayesplot)\n```\n:::\n\nTo get the samples as a dataframe:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 <- as_draws_df(fit2$draws())\nbern.2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A draws_df: 1000 iterations, 4 chains, and 2 variables\n   lp__    p\n1  -8.4 0.49\n2  -9.1 0.43\n3  -7.7 0.60\n4  -8.4 0.49\n5  -9.3 0.40\n6  -8.1 0.52\n7  -7.9 0.57\n8  -7.9 0.76\n9  -8.0 0.77\n10 -8.9 0.85\n# ... with 3990 more draws\n# ... hidden reserved variables {'.chain', '.iteration', '.draw'}\n```\n\n\n:::\n:::\n\nYou don't even need to go this far to make a plot of the posterior distribution, because `bayesplot` does it automatically:\n\n::: {.cell}\n\n```{.r .cell-code}\nmcmc_hist(fit2$draws(\"p\"), binwidth =  0.05)\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-19-1.pdf){fig-pos='H'}\n:::\n:::\n\nRather annoyingly, this plot function passes `binwidth` on to `geom_histogram`, but not `bins`! \n\nThis is skewed to the left. The reason for the skewness here is that the upper limit for $p$ is 1, and there is a reasonable chance of $p$ being close to 1, so the distribution is skewed in the opposite direction. There is basically no chance of $p$ being close to zero. If we had had more data, it is more likely that the values of $p$ near 0 and 1 would be ruled out, and then we might have ended up with something more symmetric.\n\nExtra:\nIf you remember the algebra for this, the posterior distribution for `p` actually has a beta distribution, with parameters $2+6=8$ and $2+2=4$.^[The first 2 in each case is the parameter of the prior distribution and the second number is the number of successes or failures observed in the data.] Our simulated posterior looks to have the right kind of shape to be this, being skewed to the left.\n\n\n$\\blacksquare$\n\n\n(g) The posterior predictive distribution is rather odd here: the only possible values that can be observed are 0 and 1. Nonetheless, obtain the posterior predictive distribution for these data, and explain briefly why it is not surprising that it came out as it did.\n\nSolution\n\nWith `cmdstanr`, start from what I called `bern.2`.^[I am writing this a couple of days after the Ever Given was freed from blocking the Suez Canal. One of the memes I saw about this was actually a meme-upon-a-meme: on the picture of the tiny tractor and the huge ship, someone had superimposed that picture of Bernie Sanders sitting on his chair. Feel the `bern.2`.]\n\n\nThe way to obtain the (sampled) posterior predictive distribution is to get the posterior distribution of values of $p$ in a dataframe, and make a new column as random values from the data-generating mechanism (here Bernoulli). This is easier to do and then talk about:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% \n  as_tibble() %>% \n  mutate(x = rbernoulli(4000, p)) -> ppd\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There was 1 warning in `mutate()`.\ni In argument: `x = rbernoulli(4000, p)`.\nCaused by warning:\n! `rbernoulli()` was deprecated in purrr 1.0.0.\n```\n\n\n:::\n\n```{.r .cell-code}\nppd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 6\n    lp__     p .chain .iteration .draw x    \n   <dbl> <dbl>  <int>      <int> <int> <lgl>\n 1 -8.38 0.492      1          1     1 TRUE \n 2 -9.05 0.426      1          2     2 TRUE \n 3 -7.74 0.604      1          3     3 FALSE\n 4 -8.44 0.486      1          4     4 FALSE\n 5 -9.31 0.405      1          5     5 TRUE \n 6 -8.14 0.525      1          6     6 FALSE\n 7 -7.87 0.571      1          7     7 FALSE\n 8 -7.89 0.757      1          8     8 TRUE \n 9 -7.95 0.768      1          9     9 TRUE \n10 -8.91 0.851      1         10    10 FALSE\n# i 3,990 more rows\n```\n\n\n:::\n:::\n\nThe values of `x` in the last column are TRUE for success and FALSE for failure (they could have been 1 and 0). Thus, the first `x` is a Bernoulli trial with success probability the first value of `p`, the second one uses the second value of `p`, and so on. Most of the success probabilities are bigger than 0.5, so most of the posterior predictive distribution is successes.\n\nIt seems to go better if you turn `bern.2` into a `tibble` before generating `x`.\n\n\nA bar chart would be an appropriate plot (you can either think of `x` as categorical, or as a discrete 0 or 1):\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(ppd, aes(x=x)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-21-1.pdf){fig-pos='H'}\n:::\n:::\n\nwhich shows the majority of successes in the posterior predictive distribution. The idea is that the data and the posterior predictive distribution ought to be similar, and we did indeed have a majority of successes in our data as well. \n\nYou might have been perplexed by the 4000 in the code above. `bernoulli` is vectorized, meaning that if you give it a vector of values for `p`, it will generate Bernoulli trials for each one in turn, and the whole result should be 4000 values long altogether. We'll see a way around that in a moment, but you could also do this using `rbinom` (random binomials) if you do it right:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% \n  as_tibble() %>% \n  mutate(x = rbinom(4000, 1, p)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 6\n    lp__     p .chain .iteration .draw     x\n   <dbl> <dbl>  <int>      <int> <int> <int>\n 1 -8.38 0.492      1          1     1     1\n 2 -9.05 0.426      1          2     2     0\n 3 -7.74 0.604      1          3     3     1\n 4 -8.44 0.486      1          4     4     0\n 5 -9.31 0.405      1          5     5     1\n 6 -8.14 0.525      1          6     6     1\n 7 -7.87 0.571      1          7     7     1\n 8 -7.89 0.757      1          8     8     0\n 9 -7.95 0.768      1          9     9     0\n10 -8.91 0.851      1         10    10     1\n# i 3,990 more rows\n```\n\n\n:::\n:::\n\nThere are 4000 random binomials altogether, and *each one* has one trial. This is confusing, and a less confusing way around this is to work one row at time with `rowwise`:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% \n  as_tibble() %>% \n  rowwise() %>% \n  mutate(x = rbernoulli(1, p))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 6\n# Rowwise: \n    lp__     p .chain .iteration .draw x    \n   <dbl> <dbl>  <int>      <int> <int> <lgl>\n 1 -8.38 0.492      1          1     1 FALSE\n 2 -9.05 0.426      1          2     2 TRUE \n 3 -7.74 0.604      1          3     3 FALSE\n 4 -8.44 0.486      1          4     4 TRUE \n 5 -9.31 0.405      1          5     5 FALSE\n 6 -8.14 0.525      1          6     6 FALSE\n 7 -7.87 0.571      1          7     7 TRUE \n 8 -7.89 0.757      1          8     8 TRUE \n 9 -7.95 0.768      1          9     9 FALSE\n10 -8.91 0.851      1         10    10 TRUE \n# i 3,990 more rows\n```\n\n\n:::\n:::\n\nor\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% \n  as_tibble() %>% \n  rowwise() %>%\n  mutate(x = rbinom(1, 1, p)) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 6\n# Rowwise: \n    lp__     p .chain .iteration .draw     x\n   <dbl> <dbl>  <int>      <int> <int> <int>\n 1 -8.38 0.492      1          1     1     1\n 2 -9.05 0.426      1          2     2     0\n 3 -7.74 0.604      1          3     3     1\n 4 -8.44 0.486      1          4     4     0\n 5 -9.31 0.405      1          5     5     0\n 6 -8.14 0.525      1          6     6     1\n 7 -7.87 0.571      1          7     7     1\n 8 -7.89 0.757      1          8     8     1\n 9 -7.95 0.768      1          9     9     1\n10 -8.91 0.851      1         10    10     1\n# i 3,990 more rows\n```\n\n\n:::\n:::\n\n\n\n\nExtra: I'd also like to put in a plug for the `tidybayes` package.  This works best with `rstan`, though it will work with `cmdstanr` also. The first thing it will help you with is setting up the data:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidybayes)\ntibble(x) %>% compose_data()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$x\n[1] 1 0 1 1 0 1 1 1\n\n$n\n[1] 8\n```\n\n\n:::\n:::\n\nStarting from a dataframe of data (our `x`), this returns you a list that you can submit as `data =` to `sampling`. Note that it counts how many observations you have, on the basis that you'll be sending this to Stan as well (we did).\n\nAnother thing that this will do is to handle categorical variables. Say you had something like this, with `g` being a group label:\n\n::: {.cell}\n\n```{.r .cell-code}\nd <- tribble(\n~g, ~y,\n\"a\", 10,\n\"a\", 11,\n\"a\", 12,\n\"b\", 13,\n\"b\", 14,\n\"b\", 15\n)\ncompose_data(d)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$g\n[1] 1 1 1 2 2 2\n\n$n_g\n[1] 2\n\n$y\n[1] 10 11 12 13 14 15\n\n$n\n[1] 6\n```\n\n\n:::\n:::\n\nKnowing that Stan only has `real` and `int`, it labels the groups with numbers, and keeps track of how many groups there are as well as how many observations. These are all things that Stan needs to know. See slides 32 and 34 of my lecture notes, where I prepare to fit an ANOVA model. The `tidybayes` way is, I have to say, much cleaner than the way I did it in the lecture notes. After you have fitted the model, `tidybayes` lets you go back and re-associate the real group names with the ones Stan used, so that you could get a posterior mean and interval for each of the two groups.\n\nAfter obtaining the posterior distribution, `tidybayes` also helps in understanding it. This is how you get hold of the sampled values. Install `laRs` using\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"Agasax/laRs\")\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(laRs) \nbern.2 %>% \n  spread_draws(p)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,000 x 4\n   .chain .iteration .draw     p\n    <int>      <int> <int> <dbl>\n 1      1          1     1 0.492\n 2      1          2     2 0.426\n 3      1          3     3 0.604\n 4      1          4     4 0.486\n 5      1          5     5 0.405\n 6      1          6     6 0.525\n 7      1          7     7 0.571\n 8      1          8     8 0.757\n 9      1          9     9 0.768\n10      1         10    10 0.851\n# i 3,990 more rows\n```\n\n\n:::\n:::\n\nwhich you can then summarize:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% spread_draws(p) %>% \n  median_hdi()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 6\n      p .lower .upper .width .point .interval\n  <dbl>  <dbl>  <dbl>  <dbl> <chr>  <chr>    \n1 0.677  0.410  0.905   0.95 median hdi      \n```\n\n\n:::\n:::\n\nThe median of the posterior distribution, along with a 95% Bayesian posterior interval based on the highest posterior density. There are other possibilities.\n\nOr you can plot it:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>%\n  spread_draws(p) %>% \n  ggplot(aes(x = p)) + stat_slab()\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-30-1.pdf){fig-pos='H'}\n:::\n:::\n\n(a density plot)\n\nor, posterior predictive distribution:\n\n::: {.cell}\n\n```{.r .cell-code}\nbern.2 %>% \n  spread_draws(p) %>% \n  rowwise() %>% \n  mutate(x = rbernoulli(1, p)) %>% \n  ggplot(aes(x = x)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](stan_files/figure-pdf/bayesp-31-1.pdf){fig-pos='H'}\n:::\n:::\n\n[This](https://mjskay.github.io/tidybayes/articles/tidybayes.html) is a nice introduction to `tidybayes`, with a running example. \n\n\n\n$\\blacksquare$\n\n\n\n\n\n",
    "supporting": [
      "stan_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}