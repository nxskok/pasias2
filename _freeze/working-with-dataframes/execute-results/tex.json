{
  "hash": "8abe25ef42e8d4a4b6f626393f890586",
  "result": {
    "markdown": "# Working with dataframes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n##  Tidying the Jays data\n\n\n This question is about the Blue Jays data set (that I used\nin class).\n\n\n\n(a) The Blue Jays baseball data set is at\n[link](http://ritsokiguess.site/datafiles/jays15-home.csv). Read\nit into R. Check that you have 25 rows and a bunch of variables.\n\n\n\n\n(b) Pick out only the games that were against the New York Yankees\n(the variable `opp` is equal to `NYY`). Investigate all\nthe columns.  What do you notice about these games?\n\n\n\n\n\n(c) From the whole data frame, pick out only the games where the\nattendance was more than 30,000, showing only the columns\n`attendance` and `Daynight`. How many of them are there\n(just count them)? How many are day games and how many night games\n(just count those too)?\n\n\n\n\n(d) Display the mean and standard deviation of attendances at all\nday and night games.\n\n\n\n\n(e) Make normal quantile plots of the day attendances and the night\nattendances, separately. Do you see any evidence of non-normality?\n(You would expect to on the night attendances because of the big\nopening-night value.)\n\n\n\n\n\n\n\n\n\n\n##  Cars\n\n\n My cars data file can be found at\n[link](http://ritsokiguess.site/datafiles/cars.csv). \nThe values in\nthe data file are separated by commas; the car names are up to 29\ncharacters long.  Display your results for each part after (a). In R,\ndisplaying a `tibble` normally shows its first ten lines, which\nis all you need here; there's no need to display all the lines.\n\n\n(a) Read the data into R and list the values.\n\n\n\n\n(b) Display only the car names and the countries they come from.\n\n\n\n(c) Display everything *except* horsepower:\n\n\n\n(d) Display only the cars that have 8-cylinder engines (but\ndisplay all the variables for those cars).\n\n\n\n(e) Display the cylinders and horsepower for the cars that have\nhorsepower 70 or less.\n\n\n\n(f) Find the mean and SD of gas mileage of the cars with 4 cylinders.\n\n\n\n\n\n\n\n## Dolphins\n\n Dolphins and other large marine mammals are at the top of the marine food chain, and so if there is any heavy metal pollution in the sea, it will find its way into the dolphins. The study we look at is of the concentration of mercury. This is expected to be different in males and females because the mercury in a female is transferred to her offspring during gestation and nursing. In this study, there were 28 males and 17 females of various ages. There are three columns in the data file:\n\n- `mercury`, the concentration in the liver, in micrograms per gram\n- `age` in years\n- `sex` of the dolphin, male or female.\n\nThe data are in [http://ritsokiguess.site/datafiles/dolphins.csv](http://ritsokiguess.site/datafiles/dolphins.csv) as a CSV file. This question appears to have a lot of parts, but most of them ought not to take you too long.\n\n\n\n(a) Read in and display (some of) the data.\n\n\n\n(b) Display only the two columns `mercury` and `sex`.\n\n\n\n(c) Display all the columns whose names have exactly three characters, without naming any columns.\n\n\n\n(d) Display only the mercury levels for the females. \n\n\n\n(e) What is the mean mercury concentration for all the dolphins whose age is less than 15?\n\n\n\n(f) What is the mean mercury concentration for all  the dolphins whose age is greater than 25?\n\n\n\n(g) Make a suitable graph of these data (all three columns).\n\n\n\n(h) Explain briefly how your graph and your calculations of mean mercury concentration are telling a similar story.\n\n\n\n\n\n\n\n\nMy solutions follow:\n\n\n\n\n##  Tidying the Jays data\n\n\n This question is about the Blue Jays data set (that I used\nin class).\n\n\n\n(a) The Blue Jays baseball data set is at\n[link](http://ritsokiguess.site/datafiles/jays15-home.csv). Read\nit into R. Check that you have 25 rows and a bunch of variables.\n\n\n\nSolution\n\n\nSave the URL into a variable and then read from the URL, using\n`read_csv` because it's a `.csv` file:\n\n::: {.cell}\n\n```{.r .cell-code}\nmyurl <- \"http://ritsokiguess.site/datafiles/jays15-home.csv\"\njays <- read_csv(myurl)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 25 Columns: 21\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr  (12): date, box, team, opp, result, wl, gb, winner, loser, save, Daynig...\ndbl   (7): row, game, runs, Oppruns, innings, position, attendance\nlgl   (1): venue\ntime  (1): game time\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\njays\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 25 x 21\n     row  game date   box   team  venue opp   result  runs Oppruns innings wl   \n   <dbl> <dbl> <chr>  <chr> <chr> <lgl> <chr> <chr>  <dbl>   <dbl>   <dbl> <chr>\n 1    82     7 Monda~ boxs~ TOR   NA    TBR   L          1       2      NA 4-3  \n 2    83     8 Tuesd~ boxs~ TOR   NA    TBR   L          2       3      NA 4-4  \n 3    84     9 Wedne~ boxs~ TOR   NA    TBR   W         12       7      NA 5-4  \n 4    85    10 Thurs~ boxs~ TOR   NA    TBR   L          2       4      NA 5-5  \n 5    86    11 Frida~ boxs~ TOR   NA    ATL   L          7       8      NA 5-6  \n 6    87    12 Satur~ boxs~ TOR   NA    ATL   W-wo       6       5      10 6-6  \n 7    88    13 Sunda~ boxs~ TOR   NA    ATL   L          2       5      NA 6-7  \n 8    89    14 Tuesd~ boxs~ TOR   NA    BAL   W         13       6      NA 7-7  \n 9    90    15 Wedne~ boxs~ TOR   NA    BAL   W          4       2      NA 8-7  \n10    91    16 Thurs~ boxs~ TOR   NA    BAL   W          7       6      NA 9-7  \n# i 15 more rows\n# i 9 more variables: position <dbl>, gb <chr>, winner <chr>, loser <chr>,\n#   save <chr>, `game time` <time>, Daynight <chr>, attendance <dbl>,\n#   streak <chr>\n```\n:::\n:::\n\n\nIf you must, copy and paste the spreadsheet into R Studio, and read it\nin with `read_delim` (or possibly `read_tsv`), but\nthis runs the risk of being defeated by spreadsheet cells that contain\nspaces. I don't think there are any here, but you might run into a\npitcher whose name has more than one word, like (Andy) Van Hekken, who\nis in the Seattle Mariners farm system.^[I found this by  googling, after I had scrolled past all the pages of articles about  the baseball pitcher who *lives* in a van.]\n\nAnyway, 25 rows and 21 columns. As usual, it's a tibble, so you see 10\nrows and as many columns as will fit. This is often enough to see\nwhether we have the right thing (as we appear to have, here). You can\nrun through all the columns and check that they're the right kind of\nthing; most of them are text with a few numbers and one `time`,\nwhich is ``game time``, the length of the game in hours and\nminutes, which is turned into an R `time` in hours, minutes and\nseconds. \n\nWith all those columns, `read_csv` doesn't tell you what\ncolumn specification it inferred for all of them, but you can type\n\n::: {.cell}\n\n```{.r .cell-code}\nspec(jays)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncols(\n  row = col_double(),\n  game = col_double(),\n  date = col_character(),\n  box = col_character(),\n  team = col_character(),\n  venue = col_logical(),\n  opp = col_character(),\n  result = col_character(),\n  runs = col_double(),\n  Oppruns = col_double(),\n  innings = col_double(),\n  wl = col_character(),\n  position = col_double(),\n  gb = col_character(),\n  winner = col_character(),\n  loser = col_character(),\n  save = col_character(),\n  `game time` = col_time(format = \"\"),\n  Daynight = col_character(),\n  attendance = col_double(),\n  streak = col_character()\n)\n```\n:::\n:::\n\n \n\nto find it all out.\n\n$\\blacksquare$\n\n(b) Pick out only the games that were against the New York Yankees\n(the variable `opp` is equal to `NYY`). Investigate all\nthe columns.  What do you notice about these games?\n\n\n\nSolution\n\nThis:\n\n::: {.cell}\n\n```{.r .cell-code}\njays %>% filter(opp == \"NYY\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 21\n    row  game date    box   team  venue opp   result  runs Oppruns innings wl   \n  <dbl> <dbl> <chr>   <chr> <chr> <lgl> <chr> <chr>  <dbl>   <dbl>   <dbl> <chr>\n1    92    27 Monday~ boxs~ TOR   NA    NYY   W          3       1      NA 13-14\n2    93    28 Tuesda~ boxs~ TOR   NA    NYY   L          3       6      NA 13-15\n3    94    29 Wednes~ boxs~ TOR   NA    NYY   W          5       1      NA 14-15\n# i 9 more variables: position <dbl>, gb <chr>, winner <chr>, loser <chr>,\n#   save <chr>, `game time` <time>, Daynight <chr>, attendance <dbl>,\n#   streak <chr>\n```\n:::\n:::\n\n \n\nbut you will probably need to click the little right-arrow at the top\nto see more columns. \n\nWhat I notice is that these games are all on consecutive nights\n(against the same team). This is quite common, and goes back to the\nfar-off days when teams travelled by train: teams play several games\non one visit, rather than coming back many times.^[Hockey is  similar: teams go on road trips, playing several different teams  before returning home. Hockey teams, though, tend to play each team  only once on a road trip: for example, a west coast team like the  Canucks might play a game in each of Toronto, Montreal, Boston and  New York on a road trip. Well, maybe three games in the New York  area: one each against the Rangers, Islanders and Devils.] \nYou might have noticed something else;\nthat's fine for this. For example, \n\"each of the games lasted less than three hours\", \nor \"the attendances were all small\" (since we\nlooked at all the attendances in class). I just want you to notice\nsomething meaningful that seems to be interesting about these games.\n\nYou could also print all the columns in two or more goes, using\n`select`, for example:\n\n::: {.cell}\n\n```{.r .cell-code}\njays %>% filter(opp == \"NYY\") %>% select(row:innings)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 11\n    row  game date          box   team  venue opp   result  runs Oppruns innings\n  <dbl> <dbl> <chr>         <chr> <chr> <lgl> <chr> <chr>  <dbl>   <dbl>   <dbl>\n1    92    27 Monday, May 4 boxs~ TOR   NA    NYY   W          3       1      NA\n2    93    28 Tuesday, May~ boxs~ TOR   NA    NYY   L          3       6      NA\n3    94    29 Wednesday, M~ boxs~ TOR   NA    NYY   W          5       1      NA\n```\n:::\n\n```{.r .cell-code}\njays %>% filter(opp == \"NYY\") %>% select(wl:streak)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 10\n  wl    position gb    winner loser save  `game time` Daynight attendance streak\n  <chr>    <dbl> <chr> <chr>  <chr> <chr> <time>      <chr>         <dbl> <chr> \n1 13-14        4 3.5   Dickey Mart~ Cecil 02:18       N             19217 +     \n2 13-15        5 4.5   Pineda Estr~ Mill~ 02:54       N             21519 -     \n3 14-15        3 3.5   Buehr~ Saba~ <NA>  02:30       N             21312 +     \n```\n:::\n:::\n\n \n\n$\\blacksquare$\n\n\n(c) From the whole data frame, pick out only the games where the\nattendance was more than 30,000, showing only the columns\n`attendance` and `Daynight`. How many of them are there\n(just count them)? How many are day games and how many night games\n(just count those too)?\n\n\n\nSolution\n\n\n\nTwo steps, since we selecting rows *and* columns. \n\n::: {.cell}\n\n```{.r .cell-code}\njays %>%\n  filter(attendance > 30000) %>%\n  select(c(attendance, Daynight))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 2\n  attendance Daynight\n       <dbl> <chr>   \n1      48414 N       \n2      34743 D       \n3      44794 D       \n4      30430 N       \n5      42917 D       \n6      42419 D       \n7      33086 D       \n8      37929 D       \n```\n:::\n:::\n\n \n\nOr this way, since we are selecting\n*consecutive* columns:\n\n::: {.cell}\n\n```{.r .cell-code}\njays %>%\n  filter(attendance > 30000) %>%\n  select(c(Daynight:attendance))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 2\n  Daynight attendance\n  <chr>         <dbl>\n1 N             48414\n2 D             34743\n3 D             44794\n4 N             30430\n5 D             42917\n6 D             42419\n7 D             33086\n8 D             37929\n```\n:::\n:::\n\n \n\nThere are eight games selected (see the eight rows in the\nresult). Only two of them are night games, while the other six are day\n(weekend) games.\n\nIf you wanted to, you could automate the counting, like this:\n\n::: {.cell}\n\n```{.r .cell-code}\njays %>%\n  filter(attendance > 30000) %>%\n  count(Daynight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  Daynight     n\n  <chr>    <int>\n1 D            6\n2 N            2\n```\n:::\n:::\n\n \n\nSix day games and two night games.\n\n\n$\\blacksquare$\n\n(d) Display the mean and standard deviation of attendances at all\nday and night games.\n\n\n\nSolution\n\n\nTwo steps: the grouping according to what I want to group by, then\nsummarizing according to what I want to summarize by. Since I am\nsummarizing, only the summaries find their way into the final data\nframe, so I don't need to \"select out\" the other variables:\n\n::: {.cell}\n\n```{.r .cell-code}\njays %>%\n  group_by(Daynight) %>%\n  summarize(\n    mean.att = mean(attendance),\n    sd.att = sd(attendance)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  Daynight mean.att sd.att\n  <chr>       <dbl>  <dbl>\n1 D          37885.  5775.\n2 N          20087.  8084.\n```\n:::\n:::\n\n \n\nThe mean attendances are about 38 thousand and about 20 thousand. Note\nthat the night games have much the larger SD, possibly because of the\nlarge outlier night attendance (opening night). Which we can also\ninvestigate. \n\n::: {.cell}\n\n```{.r .cell-code}\njays %>%\n  group_by(Daynight) %>%\n  summarize(\n    median.att = median(attendance),\n    iqr.att = IQR(attendance)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 3\n  Daynight median.att iqr.att\n  <chr>         <dbl>   <dbl>\n1 D            37929    8754.\n2 N            17928.   6005.\n```\n:::\n:::\n\n \nThis time, the night attendances have a *smaller* spread and a\nnoticeably smaller median (compared to the mean), so it must have been\nthe outlier that made the difference. There was another high value\nthat R marked as an outlier:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(jays, aes(x = Daynight, y = attendance)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](working-with-dataframes_files/figure-pdf/jays-dplyr-10-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nSo when you take away those unusual values, the night game attendances\nare indeed less variable.\n\nExtra: looking ahead, nhe right test, for comparing the medians\nof these non-normal data, is Mood's median test:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(smmr)\nmedian_test(jays, attendance, Daynight)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$grand_median\n[1] 21195\n\n$table\n     above\ngroup above below\n    D     7     0\n    N     5    12\n\n$test\n       what       value\n1 statistic 9.882352941\n2        df 1.000000000\n3   P-value 0.001668714\n```\n:::\n:::\n\n \n\nThere was one attendance exactly equal to the overall median (as you\nwould expect: with an odd number of data values, the median is one of\nthe data values). `smmr` removed it; if you did the test by\nhand, what happens to it depends on whether you counted aboves or\nbelows, and this will have a small effect on the P-value, though not\non the conclusion.\n\nThe overall median attendance was 21,000, and *none* of the day\ngames had attendance less than that. With the small frequencies, the\naccuracy of the P-value is a bit questionable, but taking it at face\nvalue, there *is* a significant difference between median \nattendances at day and night games.^[If you do this by  hand, you'll get a warning about the chi-squared approximation  being inaccurate. This is because of the small frequencies, and  *not* because of the outliers. Those are not damaging the test  at all.]\n\n$\\blacksquare$\n\n(e) (optional for now, but useful for laterW) Make normal quantile plots of the day attendances and the night\nattendances, separately. Do you see any evidence of non-normality?\n(You would expect to on the night attendances because of the big\nopening-night value.)\n\n\n\nSolution\n\n\nThe best way to do this is facetted normal quantile\nplots. Remember that the facetting part goes right at the end:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(jays, aes(sample = attendance)) +\n  stat_qq() + stat_qq_line() +\n  facet_wrap(~Daynight, ncol = 1)\n```\n\n::: {.cell-output-display}\n![](working-with-dataframes_files/figure-pdf/jays-dplyr-12-1.pdf){fig-pos='H'}\n:::\n:::\n\n     \nThe day attendances are pretty normal, though it is hard to be sure\nwith only 7 of them. \n\nThe night attendances are not normal. The lone point top right is the\noutlier. On top of that, the lowest attendances are not quite low enough and\nthe second-highest attendance is a bit too high, so there is a bit of\nevidence of right-skewness as well as just the one outlier. \n\nIf you leave out the `ncol=1`, you'll get the two normal\nquantile plots side by side (which means that each one is tall and\nskinny, and thus hard to read). The `ncol=1` displays all the\nfacets in *one* column, and though it would be nice to have the\ngraphs be about square, landscape mode is easier to read than portrait\nmode.  \n\nOne of the reasons for skewness is often a limit on the values of the\nvariable. The Rogers Centre has a capacity around 55,000. The day game\nattendances don't get especially close to that, which suggests that\neveryone who wants to go to the game can get a ticket. In that sort of\nsituation, you'd expect attendances to vary around a \"typical\"\nvalue, with a random deviation that depends on things like the weather\nand the opposing team, which is the typical situation in which you get\nbell-shaped data. (If the Jays often sold out their stadium for day\ngames, you'd see a lot of attendances close to the capacity, with a\nfew lower: ie., a left skew.)\n\nAs for the night games, well, there seems to be a minimum attendance\nthat the Blue Jays get, somewhere around 15,000: no matter who they're\nplaying or what the weather's like, this many people will show up\n(season-ticket holders, for example). On special occasions, such as\nopening night, the attendance will be much bigger, which points to a\n*right* skew.\n\n$\\blacksquare$\n\n\n\n\n\n\n\n##  Cars\n\n\n My cars data file can be found at\n[link](http://ritsokiguess.site/datafiles/cars.csv). \nThe values in\nthe data file are separated by commas; the car names are up to 29\ncharacters long.  Display your results for each part after (a). In R,\ndisplaying a `tibble` normally shows its first ten lines, which\nis all you need here; there's no need to display all the lines.\n\n\n(a) Read the data into R and list the values.\n\n\nSolution\n\n\n`read_csv` will do it:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/cars.csv\"\ncars <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 38 Columns: 6\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (2): car, country\ndbl (4): MPG, weight, cylinders, hp\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ncars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 38 x 6\n   car                  MPG weight cylinders    hp country\n   <chr>              <dbl>  <dbl>     <dbl> <dbl> <chr>  \n 1 Buick Skylark       28.4   2.67         4    90 U.S.   \n 2 Dodge Omni          30.9   2.23         4    75 U.S.   \n 3 Mercury Zephyr      20.8   3.07         6    85 U.S.   \n 4 Fiat Strada         37.3   2.13         4    69 Italy  \n 5 Peugeot 694 SL      16.2   3.41         6   133 France \n 6 VW Rabbit           31.9   1.92         4    71 Germany\n 7 Plymouth Horizon    34.2   2.2          4    70 U.S.   \n 8 Mazda GLC           34.1   1.98         4    65 Japan  \n 9 Buick Estate Wagon  16.9   4.36         8   155 U.S.   \n10 Audi 5000           20.3   2.83         5   103 Germany\n# i 28 more rows\n```\n:::\n:::\n\n \n$\\blacksquare$      \n\n\n(b) Display only the car names and the countries they come from.\n\n\nSolution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% select(car, country)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 38 x 2\n   car                country\n   <chr>              <chr>  \n 1 Buick Skylark      U.S.   \n 2 Dodge Omni         U.S.   \n 3 Mercury Zephyr     U.S.   \n 4 Fiat Strada        Italy  \n 5 Peugeot 694 SL     France \n 6 VW Rabbit          Germany\n 7 Plymouth Horizon   U.S.   \n 8 Mazda GLC          Japan  \n 9 Buick Estate Wagon U.S.   \n10 Audi 5000          Germany\n# i 28 more rows\n```\n:::\n:::\n\n \n\nThis *almost* works, but not quite:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% select(starts_with(\"c\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 38 x 3\n   car                cylinders country\n   <chr>                  <dbl> <chr>  \n 1 Buick Skylark              4 U.S.   \n 2 Dodge Omni                 4 U.S.   \n 3 Mercury Zephyr             6 U.S.   \n 4 Fiat Strada                4 Italy  \n 5 Peugeot 694 SL             6 France \n 6 VW Rabbit                  4 Germany\n 7 Plymouth Horizon           4 U.S.   \n 8 Mazda GLC                  4 Japan  \n 9 Buick Estate Wagon         8 U.S.   \n10 Audi 5000                  5 Germany\n# i 28 more rows\n```\n:::\n:::\n\n \n\nIt gets *all* the columns that start with `c`, which\nincludes `cylinders` as well.\n      \n$\\blacksquare$\n\n(c) Display everything *except* horsepower:\n\n\nSolution\n\n\nNaming what you *don't* want is sometimes easier:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% select(-hp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 38 x 5\n   car                  MPG weight cylinders country\n   <chr>              <dbl>  <dbl>     <dbl> <chr>  \n 1 Buick Skylark       28.4   2.67         4 U.S.   \n 2 Dodge Omni          30.9   2.23         4 U.S.   \n 3 Mercury Zephyr      20.8   3.07         6 U.S.   \n 4 Fiat Strada         37.3   2.13         4 Italy  \n 5 Peugeot 694 SL      16.2   3.41         6 France \n 6 VW Rabbit           31.9   1.92         4 Germany\n 7 Plymouth Horizon    34.2   2.2          4 U.S.   \n 8 Mazda GLC           34.1   1.98         4 Japan  \n 9 Buick Estate Wagon  16.9   4.36         8 U.S.   \n10 Audi 5000           20.3   2.83         5 Germany\n# i 28 more rows\n```\n:::\n:::\n\n \n      \n$\\blacksquare$\n\n(d) Display only the cars that have 8-cylinder engines (but\ndisplay all the variables for those cars).\n\n\nSolution\n\n\nThis:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% filter(cylinders == 8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 8 x 6\n  car                         MPG weight cylinders    hp country\n  <chr>                     <dbl>  <dbl>     <dbl> <dbl> <chr>  \n1 Buick Estate Wagon         16.9   4.36         8   155 U.S.   \n2 Chevy Malibu Wagon         19.2   3.60         8   125 U.S.   \n3 Chrysler LeBaron Wagon     18.5   3.94         8   150 U.S.   \n4 Ford LTD                   17.6   3.72         8   129 U.S.   \n5 Dodge St Regis             18.2   3.83         8   135 U.S.   \n6 Ford Country Squire Wagon  15.5   4.05         8   142 U.S.   \n7 Mercury Grand Marquis      16.5   3.96         8   138 U.S.   \n8 Chevy Caprice Classic      17     3.84         8   130 U.S.   \n```\n:::\n:::\n\n \n8 of them, all from the US.\n      \n$\\blacksquare$\n\n(e) Display the cylinders and horsepower for the cars that have\nhorsepower 70 or less.\n\n\nSolution\n\n\nThis one is selecting some observations and some variables:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% filter(hp <= 70) %>% select(cylinders:hp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 2\n  cylinders    hp\n      <dbl> <dbl>\n1         4    69\n2         4    70\n3         4    65\n4         4    65\n5         4    68\n6         4    68\n```\n:::\n:::\n\n \n\nCylinders and horsepower are consecutive columns, so we can select\nthem either using the colon `:` or by\n`c(cylinders,hp)`. \n\nYou can also do the `filter` and the\n`select` the other way around.\nThis one works because the *rows* you want to\nchoose are determined by a column you're going to keep. If you wanted\nto display the cylinders and horsepower of the cars with `mpg`\nover 30, you would have to choose the rows first, because after you've\nchosen the columns, there is no `mpg` any more.\n      \n$\\blacksquare$\n\n(f) Find the mean and SD of gas mileage of the cars with 4 cylinders.\n\n\nSolution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% filter(cylinders == 4) %>% summarize(m = mean(MPG), s = sd(MPG))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 2\n      m     s\n  <dbl> <dbl>\n1  30.0  4.18\n```\n:::\n:::\n\n \n\nOr you can get the mean and SD of gas mileage for all numbers of\ncylinders, and pick out the one you want:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>% group_by(cylinders) %>% summarize(m = mean(MPG), s = sd(MPG))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 x 3\n  cylinders     m     s\n      <dbl> <dbl> <dbl>\n1         4  30.0  4.18\n2         5  20.3 NA   \n3         6  21.1  4.08\n4         8  17.4  1.19\n```\n:::\n:::\n\n \n\nTop row is the same as before. And since the output is a data frame,\nyou can do any of these things with *that*, for example:\n\n::: {.cell}\n\n```{.r .cell-code}\ncars %>%\n  group_by(cylinders) %>%\n  summarize(m = mean(MPG), s = sd(MPG)) %>%\n  filter(cylinders == 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 3\n  cylinders     m     s\n      <dbl> <dbl> <dbl>\n1         4  30.0  4.18\n```\n:::\n:::\n\n \n\nto pick out just the right row.\nThis is a very easy kind of question to set on an exam. Just so you know.\n      \n$\\blacksquare$\n\n\n\n\n\n## Dolphins\n\n Dolphins and other large marine mammals are at the top of the marine food chain, and so if there is any heavy metal pollution in the sea, it will find its way into the dolphins. The study we look at is of the concentration of mercury. This is expected to be different in males and females because the mercury in a female is transferred to her offspring during gestation and nursing. In this study, there were 28 males and 17 females of various ages. There are three columns in the data file:\n\n- `mercury`, the concentration in the liver, in micrograms per gram\n- `age` in years\n- `sex` of the dolphin, male or female.\n\nThe data are in [http://ritsokiguess.site/datafiles/dolphins.csv](http://ritsokiguess.site/datafiles/dolphins.csv) as a CSV file. This question appears to have a lot of parts, but most of them ought not to take you too long.\n\n\n\n(a) Read in and display (some of) the data.\n\nSolution\n\n\nExactly the usual:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/dolphins.csv\"\ndolphins <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 45 Columns: 3\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (1): sex\ndbl (2): mercury, age\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\ndolphins\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 45 x 3\n   mercury   age sex  \n     <dbl> <dbl> <chr>\n 1    1.7   0.21 male \n 2    1.72  0.33 male \n 3    8.8   2    male \n 4    5.9   2.2  male \n 5  101     8.5  male \n 6   85.4  11.5  male \n 7  118    11.5  male \n 8  183    13.5  male \n 9  168    16.5  male \n10  218    16.5  male \n# i 35 more rows\n```\n:::\n:::\nThere are indeed 45 dolphins, with the males listed first and the females listed at the end (as you can check).\n\n\n$\\blacksquare$\n\n\n(b) Display only the two columns `mercury` and `sex`.\n\nSolution\n\n\nTwo ways to do it: either list both columns:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% select(mercury, sex)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 45 x 2\n   mercury sex  \n     <dbl> <chr>\n 1    1.7  male \n 2    1.72 male \n 3    8.8  male \n 4    5.9  male \n 5  101    male \n 6   85.4  male \n 7  118    male \n 8  183    male \n 9  168    male \n10  218    male \n# i 35 more rows\n```\n:::\n:::\n\nor say \"everything but age\":\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% select(-age)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 45 x 2\n   mercury sex  \n     <dbl> <chr>\n 1    1.7  male \n 2    1.72 male \n 3    8.8  male \n 4    5.9  male \n 5  101    male \n 6   85.4  male \n 7  118    male \n 8  183    male \n 9  168    male \n10  218    male \n# i 35 more rows\n```\n:::\n:::\n\nThe second one is easier coding, so is better.\n\nNote that `mercury:sex` won't do it, because that will get you `age` as well (\"`mercury` through `sex`\").\n\n\n$\\blacksquare$\n\n\n(c) Display all the columns whose names have exactly three characters, without naming any columns.\n\nSolution\n\n\nEvidently this is `age` and `sex`. We are selecting columns on the basis of their names, so we will need a select-helper. The one that works is `matches` with a regular expression. This is like the one in the lecture notes where we selected height and weight by selecting columns whose names had two letters and the second one was \"t\". In this case, the three letters can be anything, so it's three dots between the start of text and end of text:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% \nselect(matches(\"^...$\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 45 x 2\n     age sex  \n   <dbl> <chr>\n 1  0.21 male \n 2  0.33 male \n 3  2    male \n 4  2.2  male \n 5  8.5  male \n 6 11.5  male \n 7 11.5  male \n 8 13.5  male \n 9 16.5  male \n10 16.5  male \n# i 35 more rows\n```\n:::\n:::\n\n\n$\\blacksquare$\n\n\n(d) Display only the mercury levels for the females. \n\nSolution\n\n\nThis is selecting rows *and* columns, so you'll have a `select` and a `filter`. If you do the `select` first, you'll only have the mercury levels left, and you won't know which dolphins are female. So do the `filter` first:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% filter(sex == \"female\") %>% \nselect(mercury)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 17 x 1\n   mercury\n     <dbl>\n 1    2.5 \n 2    9.35\n 3    4.01\n 4   29.8 \n 5   45.3 \n 6  101   \n 7  135   \n 8  142   \n 9  180   \n10  174   \n11  247   \n12  223   \n13  167   \n14  157   \n15  177   \n16  475   \n17  342   \n```\n:::\n:::\n\n\n$\\blacksquare$\n\n\n(e) What is the mean mercury concentration for all the dolphins whose age is less than 15?\n\nSolution\n\n\nGrab only the dolphins with age less than 15 first, and then work out their mean `mercury` with `summarize`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% filter(age<15) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n      m\n  <dbl>\n1  55.5\n```\n:::\n:::\n\n55.5 (micrograms per gram), as you should say.\n\nAnother way is to define a new column that indicates whether the age is less than 15 or not, and do group-by and summarize:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% \nmutate(young = ifelse(age<15, \"yes\", \"no\")) %>% \ngroup_by(young) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  young     m\n  <chr> <dbl>\n1 no    280. \n2 yes    55.5\n```\n:::\n:::\n\nHere, you *definitely* need to extract the right number out of the output. You can also define groups by logical condition directly, which saves you a step:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% \ngroup_by(age<15) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  `age < 15`     m\n  <lgl>      <dbl>\n1 FALSE      280. \n2 TRUE        55.5\n```\n:::\n:::\n\nDoing it this way, you are probably getting some suspicions about the relationship between age and mercury concentration, but that's coming up.\n\n\n$\\blacksquare$\n\n\n(f) What is the mean mercury concentration for all  the dolphins whose age is greater than 25?\n\nSolution\n\n\nThe same three choices of method:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% filter(age>25) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 x 1\n      m\n  <dbl>\n1  309.\n```\n:::\n:::\n\n309.2 (micrograms per gram), as you should say.\n\nOr define a new column:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% \nmutate(young = ifelse(age>25, \"yes\", \"no\")) %>% \ngroup_by(young) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  young     m\n  <chr> <dbl>\n1 no     142.\n2 yes    309.\n```\n:::\n:::\n\nOr:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% \ngroup_by(age>25) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  `age > 25`     m\n  <lgl>      <dbl>\n1 FALSE       142.\n2 TRUE        309.\n```\n:::\n:::\n\nIn any of these ways, 309.2 micrograms per gram.\n\n\n$\\blacksquare$\n\n\n(g) Make a suitable graph of these data (all three columns).\n\nSolution\n\n\nThis one ought to be a gimme, but I am using the result in the next part. With two quantitative variables and one categorical, a scatterplot with the sexes indicated by colour:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dolphins, aes(x = age, y = mercury, colour = sex)) + geom_point()\n```\n\n::: {.cell-output-display}\n![](working-with-dataframes_files/figure-pdf/dolphins-12-1.pdf){fig-pos='H'}\n:::\n:::\n\nI think this is clearer without regression lines; the upward trend is clear enough, and it is not clear that the trends are linear (look at the males of the largest ages). Add a smooth trend if you like:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dolphins, aes(x = age, y = mercury, colour = sex)) + geom_point() +\ngeom_smooth()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](working-with-dataframes_files/figure-pdf/dolphins-13-1.pdf){fig-pos='H'}\n:::\n:::\n\nMercury concentration increases with age for the females, and also does  with age for the males up to about age 25, after which it levels off or decreases.\n\n\n$\\blacksquare$\n\n\n(h) Explain briefly how your graph and your calculations of mean mercury concentration are telling a similar story.\n\nSolution\n\n\nI wanted to get to a point where we were saying something interesting about the data, rather than just playing with `select` and friends.\n\nThe graph is showing an increasing trend of mercury concentration with age (at least, for all but the oldest males). The mean calculations are showing that the younger dolphins have a small mercury concentration on average, and the older dolphins have a much larger mean. These are both saying that mercury concentration is increasing with age, so they are consistent.\n\nExtra:\n\nI tried to make this fairly obvious for you by choice of age groups to compare, and this pattern holds for both males and females, so that the mean calculations didn't need to depend on `sex`. But there is no great difficulty in making it work by sex as well -- insert a `group_by` before the `summarize`:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% filter(age<15) %>% \ngroup_by(sex) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  sex        m\n  <chr>  <dbl>\n1 female  46.7\n2 male    63.2\n```\n:::\n:::\n\nand\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% filter(age>25) %>% \ngroup_by(sex) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 2\n  sex        m\n  <chr>  <dbl>\n1 female  288.\n2 male    316.\n```\n:::\n:::\n\nThe male means are slightly bigger in the two cases, though the difference between the sexes is small compared to the age effect. (I ran a regression predicting mercury concentration from age and sex, and the sex effect wasn't even significant.)\n\nA second extra: what if you wanted to divide age up into age groups for comparison of mercury concentration? This isn't always a good idea (for reasons I get into below), but if you want to do it, `cut` is your friend:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphins %>% mutate(age_group = cut(age, breaks=c(0,15,25,60))) -> dolphinsx\ndolphinsx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 45 x 4\n   mercury   age sex   age_group\n     <dbl> <dbl> <chr> <fct>    \n 1    1.7   0.21 male  (0,15]   \n 2    1.72  0.33 male  (0,15]   \n 3    8.8   2    male  (0,15]   \n 4    5.9   2.2  male  (0,15]   \n 5  101     8.5  male  (0,15]   \n 6   85.4  11.5  male  (0,15]   \n 7  118    11.5  male  (0,15]   \n 8  183    13.5  male  (0,15]   \n 9  168    16.5  male  (15,25]  \n10  218    16.5  male  (15,25]  \n# i 35 more rows\n```\n:::\n:::\n\nNote that `cut` needs input `breaks` whose first value is lower than all the ages and whose last value is higher than all the ages. The age group intervals are what mathematicians would call \"half-open\": the upper limit is included in the interval and the lower limit is not. The age of 15 is thus in the 0-15  interval and not in 15-25.\n\nNow we can work out mean mercury concentration for each age group:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphinsx %>% group_by(age_group) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  age_group     m\n  <fct>     <dbl>\n1 (0,15]     55.5\n2 (15,25]   242. \n3 (25,60]   309. \n```\n:::\n:::\n\nor even do it by sex as well:\n\n::: {.cell}\n\n```{.r .cell-code}\ndolphinsx %>% group_by(age_group, sex) %>% \nsummarize(m = mean(mercury))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'age_group'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n# Groups:   age_group [3]\n  age_group sex        m\n  <fct>     <chr>  <dbl>\n1 (0,15]    female  46.7\n2 (0,15]    male    63.2\n3 (15,25]   female 189. \n4 (15,25]   male   288. \n5 (25,60]   female 288. \n6 (25,60]   male   316. \n```\n:::\n:::\n\nNote that there is still no evidence here of the levelling off of the male mercury levels, which happened after age 25, and there was quite a lot of variability there as well.\n\nMy take is that if you have numerical data, that's what you should use, rather than breaking it up into categories. Those dolphins in the 25-60 age group, we don't know much about their actual ages, and we've seen that age and mercury concentration are closely related, so we are throwing away information by categorizing. Some people break things up into categories because that's what they know how to analyze, but that is never a good reason for you: it means that you need to go learn how to handle the original quantitative data!\n\n\n$\\blacksquare$\n\n\n\n\n",
    "supporting": [
      "working-with-dataframes_files/figure-pdf"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}