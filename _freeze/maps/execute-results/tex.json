{
  "hash": "bd85424982422c8101ee7faa68b4c988",
  "result": {
    "engine": "knitr",
    "markdown": "# Drawing maps with Leaflet\n\nPackages for this chapter:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggbiplot)\nlibrary(tidyverse)\nlibrary(ggrepel)\n```\n:::\n\n\n\n\n::: {.cell}\n\n:::\n\n\n## The Cross-City Line\n\nWhen I went to university (in Birmingham, England, a long time ago), I was very excited because I would be travelling to campus by train. My journey was on the Cross-City Line, a metro-type service with lots of stops short distances apart, but run in those days by diesel trains (the electrification came later). \n\n::: {.cell}\n\n:::\n\n\nA list of the stations on the line is in [http://ritsokiguess.site/datafiles/cross-city.csv](http://ritsokiguess.site/datafiles/cross-city.csv). There is one column in the data file, called `station`. We are going to draw a map of these.\n\n(a) Read in and display (some of) the station names.\n\n\n(b) In preparation for geocoding, create a second column in the dataframe that consists of the station names with \"station UK\" on the end. (This is to improve the chances of the geocoder finding the actual railway station.)\n\n\n(c) Look up the longitudes and latitudes of all the stations, organizing your dataframe so that they are visible.\n\n\n(d) Make a Leaflet map of the stations. Use circle markers or the \"pin\" markers as you prefer.\n\n\n\n(e) Zoom in to see whether the geocoding did indeed find each of the stations. Comment briefly on what you find.\n\n\n\n\n##  Making a map of Wisconsin\n\n\n The file\n[link](http://ritsokiguess.site/datafiles/wisconsin.txt) contains\nthe road distances (in miles) between 12 cities in Wisconsin and\nneighbouring states. We are going to try to draw a map of the\narea using Leaflet.\n\n\n(a) Read in the data, displaying\nthe data that you read in.\n\n\n\n\n(b) Make a dataframe containing the names of the locations (get rid of the columns containing distances), and add a column of the abbreviations of the states they are in. All of them are in Wisconsin (WI), except for the\nlast three: Dubuque is in Iowa (IA), St.\\ Paul is in Minnesota (MN) and Chicago\nis in Illinois (IL).\n\n\n(c) Create a new column in which the abbreviation for the state is glued on to the end of each `location`, separated by a space.\n\n\n(d) Look up the latitudes and longitudes of these twelve places.\n\n\n(e) Obtain a Leaflet map of the area containing these\ntwelve cities. \n \n\n\n\n\n##  The brain of a cat, revisited\n\nEarlier, we looked at an ethics study that had to do with a fictional brain of a fictional cat. I said\nthere was actually a *town* called Catbrain. It's in England,\nnear Bristol, and seems to be home to a street of car dealerships.\n\n\n(a) Find the latitude and longitude of \"Catbrain UK\" (though I don't think there are any others).\n\n\n(b) Draw a map of Catbrain using Leaflet.\n\n\n\n(c) Make a dataframe containing some other British cities as well as Catbrain, and find their latitudes and longitudes.\n\n\n\n(d) Draw a map containing the places you picked.\n\n\n\n\n\n\n\nMy solutions follow:\n\n\n\n\n\n\n## The Cross-City Line\n\nWhen I went to university (in Birmingham, England, a long time ago), I was very excited because I would be travelling to campus by train. My journey was on the Cross-City Line, a metro-type service with lots of stops short distances apart, but run in those days by diesel trains (the electrification came later). \n\n::: {.cell}\n\n:::\n\n\nA list of the stations on the line is in [http://ritsokiguess.site/datafiles/cross-city.csv](http://ritsokiguess.site/datafiles/cross-city.csv). There is one column in the data file, called `station`. We are going to draw a map of these.\n\n(a) Read in and display (some of) the station names.\n\nSolution\n\nNothing terribly unexpected here:\n\n::: {.cell}\n\n```{.r .cell-code}\nstations <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 24 Columns: 1\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (1): station\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nstations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 x 1\n   station              \n   <chr>                \n 1 Redditch             \n 2 Alvechurch           \n 3 Barnt Green          \n 4 Longbridge           \n 5 Northfield           \n 6 King's Norton        \n 7 Bournville           \n 8 Selly Oak            \n 9 Birmingham University\n10 Five Ways            \n# i 14 more rows\n```\n\n\n:::\n:::\n\n$\\blacksquare$\n\n(b) In preparation for geocoding, create a second column in the dataframe that consists of the station names with \"station UK\" on the end. (This is to improve the chances of the geocoder finding the actual railway station.)\n\nSolution\n\nI wrote this back into the original dataframe. Create a new one if you prefer:\n\n::: {.cell}\n\n```{.r .cell-code}\nstations %>% \n  mutate(longname = str_c(station, \" station UK\")) -> stations\nstations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 x 2\n   station               longname                        \n   <chr>                 <chr>                           \n 1 Redditch              Redditch station UK             \n 2 Alvechurch            Alvechurch station UK           \n 3 Barnt Green           Barnt Green station UK          \n 4 Longbridge            Longbridge station UK           \n 5 Northfield            Northfield station UK           \n 6 King's Norton         King's Norton station UK        \n 7 Bournville            Bournville station UK           \n 8 Selly Oak             Selly Oak station UK            \n 9 Birmingham University Birmingham University station UK\n10 Five Ways             Five Ways station UK            \n# i 14 more rows\n```\n\n\n:::\n:::\n\n$\\blacksquare$\n\n(c) Look up the longitudes and latitudes of all the stations, organizing your dataframe so that they are visible.\n\nSolution\n\nTwo steps: the first is to do the geocoding, and the second is to disentangle what comes back.\n\nFirst, then:\n\n::: {.cell}\n\n```{.r .cell-code}\nstations %>% \n  rowwise() %>% \n  mutate(ll = list(geocode_OSM(longname))) -> stations\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo results found for \"King's Norton station UK\".\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nNo results found for \"Butler's Lane station UK\".\n```\n\n\n:::\n\n```{.r .cell-code}\nstations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 x 3\n# Rowwise: \n   station               longname                         ll              \n   <chr>                 <chr>                            <list>          \n 1 Redditch              Redditch station UK              <named list [3]>\n 2 Alvechurch            Alvechurch station UK            <named list [3]>\n 3 Barnt Green           Barnt Green station UK           <named list [3]>\n 4 Longbridge            Longbridge station UK            <named list [3]>\n 5 Northfield            Northfield station UK            <named list [3]>\n 6 King's Norton         King's Norton station UK         <NULL>          \n 7 Bournville            Bournville station UK            <named list [3]>\n 8 Selly Oak             Selly Oak station UK             <named list [3]>\n 9 Birmingham University Birmingham University station UK <named list [3]>\n10 Five Ways             Five Ways station UK             <named list [3]>\n# i 14 more rows\n```\n\n\n:::\n:::\n\nThe longitudes and latitudes are hidden in the list-column that I called `ll`, so the second step is to get them out:\n\n::: {.cell}\n\n```{.r .cell-code}\nstations %>% unnest_wider(ll) %>% \n  unnest_wider(coords) -> stations\nstations\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 x 6\n   station               longname                       query     x     y bbox  \n   <chr>                 <chr>                          <chr> <dbl> <dbl> <list>\n 1 Redditch              Redditch station UK            Redd~ -1.95  52.3 <bbox>\n 2 Alvechurch            Alvechurch station UK          Alve~ -1.97  52.3 <bbox>\n 3 Barnt Green           Barnt Green station UK         Barn~ -1.99  52.4 <bbox>\n 4 Longbridge            Longbridge station UK          Long~ -1.98  52.4 <bbox>\n 5 Northfield            Northfield station UK          Nort~ -1.97  52.4 <bbox>\n 6 King's Norton         King's Norton station UK       <NA>  NA     NA   <NULL>\n 7 Bournville            Bournville station UK          Bour~ -1.93  52.4 <bbox>\n 8 Selly Oak             Selly Oak station UK           Sell~ -1.94  52.4 <bbox>\n 9 Birmingham University Birmingham University station~ Birm~ -1.94  52.5 <bbox>\n10 Five Ways             Five Ways station UK           Five~ -1.91  52.5 <bbox>\n# i 14 more rows\n```\n\n\n:::\n:::\n\nThe two `unnest_wider`s are because the longitudes and latitudes are hidden inside a thing called `coords` which is itself nested within `ll`. Do the first `unnest_wider`, and see what you have. This will tell you that you need to do another one. \n\nThe values seem mostly reasonable; this is the UK, most of which is slightly west of the Greenwich meridian, and the latitudes look sensible given that the UK is north of southern Ontario. You might find that some of the stations were not found at all (which will give you warnings the rest of the way), and you might find that something was found for a station but the *wrong* thing,  which will show up on your map as a place way off the trend of the other places. \n\n$\\blacksquare$\n\n(d) Make a Leaflet map of the stations. Use circle markers or the \"pin\" markers as you prefer.\n\n\nSolution\n\nI used the pin markers (with `addMarkers`), though `addCircleMarkers` is as good. The code for drawing the map is always the same; the work here is in setting up the geocoding:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = stations) %>% \n  addTiles() %>% \n  addMarkers(lng = ~x, lat = ~y)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in validateCoords(lng, lat, funcName): Data contains 2 rows with either\nmissing or invalid lat/lon values and will be ignored\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/cross-city-6-1.pdf){fig-pos='H'}\n:::\n:::\n\nYou might find that some of the markers are off a straight line through Birmingham. In these cases, the geocoder found a different place with (apparently) the same name, or a name that was close enough to similar. This seems to be different each time you run it, so you can try again.\n\nThis (mostly) seems to extend across the city of Birmingham, as it should. There are quite a lot of stations, so the pins overlap each other. Zoom in to see them in a bit more detail, or zoom out to orient yourself if your UK geography needs some work.\n\n$\\blacksquare$\n\n(e) Zoom in to see whether the geocoding did indeed find each of the stations. Comment briefly on what you find.\n\nSolution\n\nThe stations go south to north, so the most southerly one you find should be Redditch and the most northerly is Lichfield Trent Valley. \n\nIf you zoom in enough, you'll see where the railway line goes (a grey line). The points seem to be mainly close to it. But if you zoom in a bit more, some of the pins are right on the railway, and some of them are a bit off, because the geocoder found the centre of the place (or something else named after the place) rather than its railway station. For example, when I did it, Gravelly Hill station was right where it should be, but Aston was not.^[If you're a soccer fan, this Aston is what Aston Villa is named after. See if you can find the team's stadium Villa Park on your map, which is actually closer to Witton station on another line.]\n\nExtra: `geocode_OSM` uses a free geocoder called Nominatim. This has some options. The defaults are to return only the first \"hit\", and to return just the coordinates and the \"bounding box\". These can be changed. Let's see what we can find for Aston:\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(where = \"Aston UK\") %>% \n  mutate(info = list(geocode_OSM(where, return.first.only = FALSE,\n                            details = TRUE))) -> d\nd         \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 2\n  where    info       \n  <chr>    <list>     \n1 Aston UK <list [10]>\n```\n\n\n:::\n:::\nThere are now 10 things returned. Let's unnest this and see what we have:\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% unnest(info) %>% \n  unnest_wider(info)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 13\n   where    query coords bbox   place_id osm_type osm_id place_rank display_name\n   <chr>    <chr> <list> <list> <chr>    <chr>    <chr>  <chr>      <chr>       \n 1 Aston UK Asto~ <dbl>  <bbox> 2725904~ node     96663~ 18         Aston, Birm~\n 2 Aston UK Asto~ <dbl>  <bbox> 2715954~ relation 947997 20         Aston, Hope~\n 3 Aston UK Asto~ <dbl>  <bbox> 2712395~ relation 14404~ 20         Aston, Sutt~\n 4 Aston UK Asto~ <dbl>  <bbox> 2725861~ node     59202~ 30         Aston, Love~\n 5 Aston UK Asto~ <dbl>  <bbox> 2705863~ node     48708~ 19         Aston, Flin~\n 6 Aston UK Asto~ <dbl>  <bbox> 2732244~ relation 35941~ 20         Aston, East~\n 7 Aston UK Asto~ <dbl>  <bbox> 2746016~ node     26127~ 19         Aston, West~\n 8 Aston UK Asto~ <dbl>  <bbox> 2713394~ node     17098~ 19         Aston, Ches~\n 9 Aston UK Asto~ <dbl>  <bbox> 2732567~ node     23777~ 19         Aston, East~\n10 Aston UK Asto~ <dbl>  <bbox> 2705111~ node     33782~ 19         Aston, Shro~\n# i 4 more variables: class <chr>, type <chr>, importance <chr>, icon <chr>\n```\n\n\n:::\n:::\n\nThere are 10 locations it found matching \"Aston UK\", and for each of those there is the information you see, a total of 12 columns' worth in addition to the name of the place we are looking up. Perhaps the most interesting are the columns `class` and `type` near the end (keep scrolling right):\n\n::: {.cell}\n\n```{.r .cell-code}\nd %>% unnest(info) %>% \n  unnest_wider(info) %>% \n  select(where, class, type)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 x 3\n   where    class    type          \n   <chr>    <chr>    <chr>         \n 1 Aston UK place    town          \n 2 Aston UK boundary administrative\n 3 Aston UK boundary administrative\n 4 Aston UK railway  station       \n 5 Aston UK place    village       \n 6 Aston UK boundary administrative\n 7 Aston UK place    village       \n 8 Aston UK place    village       \n 9 Aston UK place    village       \n10 Aston UK place    village       \n```\n\n\n:::\n:::\n\nYou can see which one is the railway station. \n\nThis makes me think that with sufficient patience we could do this for all our places, and pick out the one that is the station:\n\n::: {.cell}\n\n```{.r .cell-code}\nstations <- read_csv(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 24 Columns: 1\n-- Column specification --------------------------------------------------------\nDelimiter: \",\"\nchr (1): station\n\ni Use `spec()` to retrieve the full column specification for this data.\ni Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nstations %>% \n  mutate(longname = str_c(station, \" UK\")) %>% \n  rowwise() %>% \n  mutate(ll = list(geocode_OSM(longname, \n                   return.first.only = FALSE,\n                   details = TRUE))) -> stations2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstations2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 x 3\n# Rowwise: \n   station               longname                 ll         \n   <chr>                 <chr>                    <list>     \n 1 Redditch              Redditch UK              <list [2]> \n 2 Alvechurch            Alvechurch UK            <list [3]> \n 3 Barnt Green           Barnt Green UK           <list [2]> \n 4 Longbridge            Longbridge UK            <list [7]> \n 5 Northfield            Northfield UK            <list [10]>\n 6 King's Norton         King's Norton UK         <list [2]> \n 7 Bournville            Bournville UK            <list [4]> \n 8 Selly Oak             Selly Oak UK             <list [2]> \n 9 Birmingham University Birmingham University UK <list [6]> \n10 Five Ways             Five Ways UK             <list [10]>\n# i 14 more rows\n```\n\n\n:::\n:::\n\nThe number in the `ll` column tells you how many things the geocoder found that match the input `longname`. One of each of these is, we hope, a railway station.\n\n::: {.cell}\n\n```{.r .cell-code}\nstations2 %>% unnest(ll) %>% \n  unnest_wider(ll, names_sep = \"_\") %>% \n  select(station, ll_coords, ll_class, ll_type) %>% \n  filter(ll_class == \"railway\", ll_type == \"station\") %>% \n  unnest_wider(ll_coords) -> d\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 19 x 5\n   station                    x     y ll_class ll_type\n   <chr>                  <dbl> <dbl> <chr>    <chr>  \n 1 Alvechurch             -1.97  52.3 railway  station\n 2 Barnt Green            -1.99  52.4 railway  station\n 3 Longbridge             -1.98  52.4 railway  station\n 4 Northfield             -1.97  52.4 railway  station\n 5 Bournville             -1.93  52.4 railway  station\n 6 Selly Oak              -1.94  52.4 railway  station\n 7 Five Ways              -1.91  52.5 railway  station\n 8 Birmingham New Street  -1.90  52.5 railway  station\n 9 Duddeston              -1.87  52.5 railway  station\n10 Aston                  -1.87  52.5 railway  station\n11 Gravelly Hill          -1.85  52.5 railway  station\n12 Erdington              -1.84  52.5 railway  station\n13 Chester Road           -1.83  52.5 railway  station\n14 Wylde Green            -1.83  52.5 railway  station\n15 Sutton Coldfield       -1.83  52.6 railway  station\n16 Four Oaks              -1.83  52.6 railway  station\n17 Blake Street           -1.84  52.6 railway  station\n18 Shenstone              -1.84  52.6 railway  station\n19 Lichfield Trent Valley -1.80  52.7 railway  station\n```\n\n\n:::\n:::\n\n\nIf you want to see how this works, run it one line at a time.\n\nWe almost got there. We're missing University^[The station is called just University, not Birmingham University, which makes it hard to find.] and Lichfield City stations, but it looks as if we got the rest:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = d) %>% \n  addTiles() %>% \n  addMarkers(lng = ~x, lat = ~y)\n```\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/cross-city-12-1.pdf){fig-pos='H'}\n:::\n:::\n\nIf you zoom in, you'll see that the ones we got are all the actual stations, and not the area from which the station takes its name.\n\n$\\blacksquare$\n\n\n\n##  Making a map of Wisconsin\n\n\nThe file\n[link](http://ritsokiguess.site/datafiles/wisconsin.txt) contains\nthe road distances (in miles) between 12 cities in Wisconsin and\nneighbouring states. We are going to try to draw a map of the\narea using Leaflet.\n\n\n(a) Read in the data, displaying\nthe data that you read in.\n\n\nSolution\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_url <- \"http://ritsokiguess.site/datafiles/wisconsin.txt\"\nwisc <- read_table(my_url)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n-- Column specification --------------------------------------------------------\ncols(\n  location = col_character(),\n  Appleton = col_double(),\n  Beloit = col_double(),\n  Fort.Atkinson = col_double(),\n  Madison = col_double(),\n  Marshfield = col_double(),\n  Milwaukee = col_double(),\n  Monroe = col_double(),\n  Superior = col_double(),\n  Wausau = col_double(),\n  Dubuque = col_double(),\n  St.Paul = col_double(),\n  Chicago = col_double()\n)\n```\n\n\n:::\n\n```{.r .cell-code}\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 13\n   location    Appleton Beloit Fort.Atkinson Madison Marshfield Milwaukee Monroe\n   <chr>          <dbl>  <dbl>         <dbl>   <dbl>      <dbl>     <dbl>  <dbl>\n 1 Appleton           0    130            98     102        103       100    149\n 2 Beloit           130      0            33      50        185        73     33\n 3 Fort.Atkin~       98     33             0      36        164        54     58\n 4 Madison          102     50            36       0        138        77     47\n 5 Marshfield       103    185           164     138          0       184    170\n 6 Milwaukee        100     73            54      77        184         0    107\n 7 Monroe           149     33            58      47        170       107      0\n 8 Superior         315    377           359     330        219       394    362\n 9 Wausau            91    186           166     139         45       181    186\n10 Dubuque          196     94           119      95        186       168     61\n11 St.Paul          257    304           287     258        161       322    289\n12 Chicago          186     97           113     146        276        93    130\n# i 5 more variables: Superior <dbl>, Wausau <dbl>, Dubuque <dbl>,\n#   St.Paul <dbl>, Chicago <dbl>\n```\n\n\n:::\n:::\n\n       \n\nThe first time I did this, I had a blank line on the end of the data\nfile, so I had a blank `location` and missing values for all\nthe distances for it. I tidied that up before sharing the file with\nyou, though.\n\n$\\blacksquare$\n\n\n(b) Make a dataframe containing the names of the locations (get rid of the columns containing distances), and add a column of the abbreviations of the states they are in. All of them are in Wisconsin (WI), except for the\nlast three: Dubuque is in Iowa (IA), St.\\ Paul is in Minnesota (MN) and Chicago\nis in Illinois (IL).\n\nSolution\n\nThere seems to be a bit of base R attached to this, however you do it. I am going to create a dataframe pretending they are all in Wisconsin, and then fix it up afterwards:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  select(!where(is.numeric)) %>% \n  mutate(state = \"WI\") -> wisc\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   location      state\n   <chr>         <chr>\n 1 Appleton      WI   \n 2 Beloit        WI   \n 3 Fort.Atkinson WI   \n 4 Madison       WI   \n 5 Marshfield    WI   \n 6 Milwaukee     WI   \n 7 Monroe        WI   \n 8 Superior      WI   \n 9 Wausau        WI   \n10 Dubuque       WI   \n11 St.Paul       WI   \n12 Chicago       WI   \n```\n\n\n:::\n:::\n\n(I checked that in this question I didn't need the road distances for anything, so I saved it back into the original dataframe. Also, the `select` is unnecessarily fancy: I could have just selected the `location` column, but this one says \"don't select any of the columns that are numeric\".) \n\nNow we have to fix up the states of the last three places, which is where the base R seems to come in (but see the Extra):\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc$state[10] <- \"IA\"\nwisc$state[11] <- \"MN\"\nwisc$state[12] <- \"IL\"\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   location      state\n   <chr>         <chr>\n 1 Appleton      WI   \n 2 Beloit        WI   \n 3 Fort.Atkinson WI   \n 4 Madison       WI   \n 5 Marshfield    WI   \n 6 Milwaukee     WI   \n 7 Monroe        WI   \n 8 Superior      WI   \n 9 Wausau        WI   \n10 Dubuque       IA   \n11 St.Paul       MN   \n12 Chicago       IL   \n```\n\n\n:::\n:::\n\nThe states of the last three locations are now correct.\n\nExtra: I didn't know about the following until literally just now, but there is a `tidyverse` way to do this as well (that may look familiar to those of you that know about SQL). Let's start by pretending again that everything is in Wisconsin:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  mutate(state = \"WI\") -> wisc2\nwisc2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   location      state\n   <chr>         <chr>\n 1 Appleton      WI   \n 2 Beloit        WI   \n 3 Fort.Atkinson WI   \n 4 Madison       WI   \n 5 Marshfield    WI   \n 6 Milwaukee     WI   \n 7 Monroe        WI   \n 8 Superior      WI   \n 9 Wausau        WI   \n10 Dubuque       WI   \n11 St.Paul       WI   \n12 Chicago       WI   \n```\n\n\n:::\n:::\n\nand then change the ones that need changing. What you do is to make a little dataframe of the ones that need changing:\n\n::: {.cell}\n\n```{.r .cell-code}\nchanges <- tribble(\n  ~location, ~state,\n  \"Dubuque\", \"IA\",\n  \"St.Paul\", \"MN\",\n  \"Chicago\", \"IL\"\n)\nchanges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  location state\n  <chr>    <chr>\n1 Dubuque  IA   \n2 St.Paul  MN   \n3 Chicago  IL   \n```\n\n\n:::\n:::\n\nNote that the columns in here have *exactly* the same names as the ones in the original dataframe where everything was in Wisconsin. \n\n\nI did this by copy-pasting the city names whose states needed changing out of the display of my `wisc2`. You might think that a left join is what we need now, and it almost is. Note that I want to match the locations but *not* the states:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc2 %>% left_join(changes, join_by(location))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n   location      state.x state.y\n   <chr>         <chr>   <chr>  \n 1 Appleton      WI      <NA>   \n 2 Beloit        WI      <NA>   \n 3 Fort.Atkinson WI      <NA>   \n 4 Madison       WI      <NA>   \n 5 Marshfield    WI      <NA>   \n 6 Milwaukee     WI      <NA>   \n 7 Monroe        WI      <NA>   \n 8 Superior      WI      <NA>   \n 9 Wausau        WI      <NA>   \n10 Dubuque       WI      IA     \n11 St.Paul       WI      MN     \n12 Chicago       WI      IL     \n```\n\n\n:::\n:::\n\nand the story here is that if `state.y` has a value, use that, otherwise use  the value in `state.x`. This can even be done: there is a function `coalesce`^[I knew this existed, but I couldn't remember what it was called, which made it hard to search for. My first port of call was `na_if`, which converts values to `NA`, the opposite of what I wanted. But from its See Also I got `na_replace`, and from the See Also of that, I found out what `coalesce` does.]  that will do exactly that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc2 %>% left_join(changes, join_by(location)) %>% \n  mutate(state=coalesce(state.y, state.x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 4\n   location      state.x state.y state\n   <chr>         <chr>   <chr>   <chr>\n 1 Appleton      WI      <NA>    WI   \n 2 Beloit        WI      <NA>    WI   \n 3 Fort.Atkinson WI      <NA>    WI   \n 4 Madison       WI      <NA>    WI   \n 5 Marshfield    WI      <NA>    WI   \n 6 Milwaukee     WI      <NA>    WI   \n 7 Monroe        WI      <NA>    WI   \n 8 Superior      WI      <NA>    WI   \n 9 Wausau        WI      <NA>    WI   \n10 Dubuque       WI      IA      IA   \n11 St.Paul       WI      MN      MN   \n12 Chicago       WI      IL      IL   \n```\n\n\n:::\n:::\n\nThe idea behind `coalesce` is that you give it a list of columns, and the first one of those that is *not missing* gives its value to the new column. So I feed it `state.y` *first*, and then `state.x`, and the new `state` contains the right things. (Can you explain what happens if you do it the other way around?)\n\nBut, there is a better way. Let's go back to our all-Wisconsin dataframe:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   location      state\n   <chr>         <chr>\n 1 Appleton      WI   \n 2 Beloit        WI   \n 3 Fort.Atkinson WI   \n 4 Madison       WI   \n 5 Marshfield    WI   \n 6 Milwaukee     WI   \n 7 Monroe        WI   \n 8 Superior      WI   \n 9 Wausau        WI   \n10 Dubuque       WI   \n11 St.Paul       WI   \n12 Chicago       WI   \n```\n\n\n:::\n:::\n\nand our dataframe of corrections to make:\n\n::: {.cell}\n\n```{.r .cell-code}\nchanges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 x 2\n  location state\n  <chr>    <chr>\n1 Dubuque  IA   \n2 St.Paul  MN   \n3 Chicago  IL   \n```\n\n\n:::\n:::\n\nWe can make those changes in one step, thus:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc2 %>% \n  rows_update(changes) -> wisc\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nMatching, by = \"location\"\n```\n\n\n:::\n\n```{.r .cell-code}\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 2\n   location      state\n   <chr>         <chr>\n 1 Appleton      WI   \n 2 Beloit        WI   \n 3 Fort.Atkinson WI   \n 4 Madison       WI   \n 5 Marshfield    WI   \n 6 Milwaukee     WI   \n 7 Monroe        WI   \n 8 Superior      WI   \n 9 Wausau        WI   \n10 Dubuque       IA   \n11 St.Paul       MN   \n12 Chicago       IL   \n```\n\n\n:::\n:::\n\nThis works because the *first* column of `changes`, namely `location`, is the one that is looked up in `wisc2`. (`rows_update` has a `by` in the same way that `left_join` does if you want to change this.) So all three locations in `changes` are looked up in `wisc2`, and any that match have their `state` changed to the one in `changes`.\n\nIn database terms, the `location` is known as a \"key\" column. That means that each city appears *once only* in the column, and so the replacements in `wisc` are only happening once. To a statistician, `location` is an \"identifier variable\", identifying the individuals in the dataset. Unless you are doing something like repeated measures, each individual will only give you one measurement, but even then, if you have wide format, the identifier variables will still only appear once.\n\nMagic. Now that I have learned about this, I will be using it a lot.\n\n$\\blacksquare$\n\n(c) Create a new column in which the abbreviation for the state is glued on to the end of each `location`, separated by a space.\n\nSolution\n\nA couple of ways: a literal gluing, using `paste`:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  mutate(lookup = paste(location, state))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n   location      state lookup          \n   <chr>         <chr> <chr>           \n 1 Appleton      WI    Appleton WI     \n 2 Beloit        WI    Beloit WI       \n 3 Fort.Atkinson WI    Fort.Atkinson WI\n 4 Madison       WI    Madison WI      \n 5 Marshfield    WI    Marshfield WI   \n 6 Milwaukee     WI    Milwaukee WI    \n 7 Monroe        WI    Monroe WI       \n 8 Superior      WI    Superior WI     \n 9 Wausau        WI    Wausau WI       \n10 Dubuque       IA    Dubuque IA      \n11 St.Paul       MN    St.Paul MN      \n12 Chicago       IL    Chicago IL      \n```\n\n\n:::\n:::\n\nor the same idea using `str_c` from `stringr` (part of the tidyverse), only this time you have to supply the space yourself:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  mutate(lookup = str_c(location, \" \", state))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 3\n   location      state lookup          \n   <chr>         <chr> <chr>           \n 1 Appleton      WI    Appleton WI     \n 2 Beloit        WI    Beloit WI       \n 3 Fort.Atkinson WI    Fort.Atkinson WI\n 4 Madison       WI    Madison WI      \n 5 Marshfield    WI    Marshfield WI   \n 6 Milwaukee     WI    Milwaukee WI    \n 7 Monroe        WI    Monroe WI       \n 8 Superior      WI    Superior WI     \n 9 Wausau        WI    Wausau WI       \n10 Dubuque       IA    Dubuque IA      \n11 St.Paul       MN    St.Paul MN      \n12 Chicago       IL    Chicago IL      \n```\n\n\n:::\n:::\n\nor a way you might have forgotten, using `unite` (which is the inverse of `separate_wider`):\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  unite(lookup, c(location, state), sep = \" \") -> wisc\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 1\n   lookup          \n   <chr>           \n 1 Appleton WI     \n 2 Beloit WI       \n 3 Fort.Atkinson WI\n 4 Madison WI      \n 5 Marshfield WI   \n 6 Milwaukee WI    \n 7 Monroe WI       \n 8 Superior WI     \n 9 Wausau WI       \n10 Dubuque IA      \n11 St.Paul MN      \n12 Chicago IL      \n```\n\n\n:::\n:::\n\nThis last one is my favourite, because it gets rid of the two constituent columns `location` and `state` that we don't need any more. The syntax is the name of the new column, a vector of columns to unite together, and (optionally) what to separate the joined-together values with. The default for that is an underscore, but here we want a space because that's what the geocoder (coming up) expects.\n\n$\\blacksquare$\n\n(d) Look up the latitudes and longitudes of these twelve places.\n\nSolution\n\nThis is geocoding, with the disentangling afterwards that is (I hope) becoming familiar:\n\n::: {.cell}\n\n```{.r .cell-code}\nwisc %>% \n  rowwise() %>% \n  mutate(ll = list(geocode_OSM(lookup))) %>% \n  unnest_wider(ll) %>% \n  unnest_wider(coords) -> wisc\nwisc\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 x 5\n   lookup           query                x     y bbox      \n   <chr>            <chr>            <dbl> <dbl> <list>    \n 1 Appleton WI      Appleton WI      -88.4  44.3 <bbox [4]>\n 2 Beloit WI        Beloit WI        -89.0  42.5 <bbox [4]>\n 3 Fort.Atkinson WI Fort.Atkinson WI -88.8  42.9 <bbox [4]>\n 4 Madison WI       Madison WI       -89.4  43.1 <bbox [4]>\n 5 Marshfield WI    Marshfield WI    -90.2  44.7 <bbox [4]>\n 6 Milwaukee WI     Milwaukee WI     -87.9  43.0 <bbox [4]>\n 7 Monroe WI        Monroe WI        -90.6  43.9 <bbox [4]>\n 8 Superior WI      Superior WI      -92.1  46.7 <bbox [4]>\n 9 Wausau WI        Wausau WI        -89.6  45.0 <bbox [4]>\n10 Dubuque IA       Dubuque IA       -90.7  42.5 <bbox [4]>\n11 St.Paul MN       St.Paul MN       -93.1  44.9 <bbox [4]>\n12 Chicago IL       Chicago IL       -87.6  41.9 <bbox [4]>\n```\n\n\n:::\n:::\n\nYes, I forgot the `rowwise` as well the first time.\n\n$\\blacksquare$\n\n(e) Obtain a Leaflet map of the area containing these\ntwelve cities. \n \nSolution\n\nThe usual:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = wisc) %>% \n  addTiles() %>% \n  addCircleMarkers(lng = ~x, lat = ~y) -> locs\nlocs\n```\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/wisconsin2-15-1.pdf){fig-pos='H'}\n:::\n:::\n\nThe nice thing about this map is that you can play with it: zoom it (using the plus/minus on the map or your mouse wheel), or move it around by clicking and dragging. To identify the cities: well, the big ones are obvious, and you can zoom in to identify the others. (You have to zoom in quite a long way to find Monroe, and the geocoder seems to have found its airport, which is not actually in the city.)\n\nI like identifying the cities with circles, but there are other possibilities, such as \"icon markers\" that look like Google map pins:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = wisc) %>% \n  addTiles() %>% \n  addMarkers(lng = ~x, lat = ~y) -> locs\nlocs\n```\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/wisconsin2-16-1.pdf){fig-pos='H'}\n:::\n:::\n\nYou can even attach text to the markers that appears when you click on them, but that's farther than I would go here.\n\n\n$\\blacksquare$\n\n\n\n\n##  The brain of a cat, revisited\n\nEarlier, we looked at an ethics study that had to do with a fictional brain of a fictional cat. I said\nthere was actually a *town* called Catbrain. It's in England,\nnear Bristol, and seems to be home to a street of car dealerships.\n\n\n(a) Find the latitude and longitude of \"Catbrain UK\" (though I don't think there are any others).\n\nSolution\n\nMake sure you have these two packages loaded:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(leaflet)\nlibrary(tmaptools)\n```\n:::\n\nTo find the latitude and longitude of Catbrain:\n\n::: {.cell}\n\n```{.r .cell-code}\ncatbrain <- tibble(place = \"Catbrain UK\")\ncatbrain %>% mutate(ll = list(geocode_OSM(place))) %>% \n  unnest_wider(ll) %>% \n  unnest_wider(coords) -> catbrain\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncatbrain\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 x 5\n  place       query           x     y bbox      \n  <chr>       <chr>       <dbl> <dbl> <list>    \n1 Catbrain UK Catbrain UK -2.61  51.5 <bbox [4]>\n```\n\n\n:::\n:::\n\n\nRemember that the output from `geocode_OSM` is a list, and it has in it a thing called `coords` that is the longitude and latitude together, and another thing called `bbox` that we don't use. So we have to `unnest` *twice* to get the longitude (as `x`) and the latitude (as `y`) out for drawing in a moment.\n\n$\\blacksquare$\n\n(b) Draw a map of Catbrain using Leaflet.\n\n\nSolution\n\nThat goes this way:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = catbrain) %>% \n  addTiles() %>% \n  addCircleMarkers(lng = ~x, lat = ~y) -> catbrain_map\ncatbrain_map\n```\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/catbrain-4-1.pdf){fig-pos='H'}\n:::\n:::\n\n\n \n \nThere are car dealerships are along Lysander Road. Zoom in\nto see them. Or zoom out to see where this is. You can keep zooming out until you know where you are, using the plus and minus buttons, or your mouse wheel.\n\n\nThe name Catbrain, according to\n[link](http://www.bristolpost.co.uk/news/history/name-catbrain-hill-came-825247),\nmeans \"rough stony soil\", from Middle English, and has nothing to do\nwith cats or their brains at all.\n\n\nExtra: I was actually surprised that this worked at all, because with only one point, how does it know what scale to draw the map? Also, unless your UK geography is really good, you won't have any clue about exactly where this is. That's the reason for the next part.\n\n$\\blacksquare$\n\n(c) Make a dataframe containing some other British cities as well as Catbrain, and find their latitudes and longitudes.\n\n\nSolution\n\nI chose the cities below, mostly somewhere near Catbrain. You could fire up a Google map, zoom it out until it contains something you know, and pick some places you've heard of. (I happen to know British geography pretty well, so I just picked some mostly nearby places out of my head. I didn't really want to pick London, but I figured this was the one *you* might know.)\n\n::: {.cell}\n\n```{.r .cell-code}\ncatbrain2 <- tribble(\n  ~where,\n  \"Catbrain UK\",\n  \"Bristol UK\",\n  \"Taunton UK\",\n  \"Newport UK\",\n  \"Gloucester UK\",\n  \"Cardiff UK\",\n  \"Birmingham UK\",\n  \"London UK\",\n  \"Caldicot UK\"\n)\ncatbrain2 %>%\n  rowwise() %>% \n  mutate(ll = list(geocode_OSM(where))) %>% \n  unnest_wider(ll) %>% \n  unnest_wider(coords) -> catbrain2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncatbrain2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 x 5\n  where         query              x     y bbox      \n  <chr>         <chr>          <dbl> <dbl> <list>    \n1 Catbrain UK   Catbrain UK   -2.61   51.5 <bbox [4]>\n2 Bristol UK    Bristol UK    -2.60   51.5 <bbox [4]>\n3 Taunton UK    Taunton UK    -3.10   51.0 <bbox [4]>\n4 Newport UK    Newport UK    -3.00   51.6 <bbox [4]>\n5 Gloucester UK Gloucester UK -2.25   51.9 <bbox [4]>\n6 Cardiff UK    Cardiff UK    -3.18   51.5 <bbox [4]>\n7 Birmingham UK Birmingham UK -1.90   52.5 <bbox [4]>\n8 London UK     London UK     -0.144  51.5 <bbox [4]>\n9 Caldicot UK   Caldicot UK   -2.75   51.6 <bbox [4]>\n```\n\n\n:::\n:::\n\n\nThe first time I did this, I forgot the `rowwise`, which we didn't need the first time (there was only one place), but here, it causes odd problems if you omit it. \n\n$\\blacksquare$\n\n(d) Draw a map containing the places you picked.\n\nSolution\n\nThe map-drawing is almost the same, just changing the dataframe:\n\n::: {.cell}\n\n```{.r .cell-code}\nleaflet(data = catbrain2) %>% \n  addTiles() %>% \n  addCircleMarkers(lng = ~x, lat = ~y)\n```\n\n::: {.cell-output-display}\n![](maps_files/figure-pdf/catbrain-7-1.pdf){fig-pos='H'}\n:::\n:::\n\n \n\nNow, if you have any sense of the geography of the UK, you know where\nyou are.  The big river (the Severn) is\nthe border between England and Wales, so\nthe places above and to the left of it are in Wales, including\nCaldicot (see question about Roman pottery).\n\nYou can zoom this map *in* (once you have figured out which of the circles is Catbrain) and find Lysander Road again, and also the M5 (see below).\n\nMore irrelevant extra: the M5 is one of the English \"motorways\" (like 400-series highways\nor US Interstates). The M5 goes from Birmingham to Exeter. You can\ntell that this is England because of the huge number of traffic\ncircles, known there as \"roundabouts\". One of the first things they\nteach you in British driving schools is how to handle roundabouts:\nwhich lane to approach them in, which (stick-shift) gear to be in, and\nwhen you're supposed to signal where you're going. I hope I still\nremember all that for when I next drive in England!\n    \n$\\blacksquare$\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}